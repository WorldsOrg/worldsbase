"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-virtual/dist/cjs/index.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@tanstack/react-virtual/dist/cjs/index.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, {\n    value: \"Module\"\n});\nconst React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nconst reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nconst virtualCore = __webpack_require__(/*! @tanstack/virtual-core */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/cjs/index.cjs\");\nfunction _interopNamespaceDefault(e) {\n    const n = Object.create(null, {\n        [Symbol.toStringTag]: {\n            value: \"Module\"\n        }\n    });\n    if (e) {\n        for(const k in e){\n            if (k !== \"default\") {\n                const d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: ()=>e[k]\n                });\n            }\n        }\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nconst React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React__namespace.useLayoutEffect : React__namespace.useEffect;\nfunction useVirtualizerBase(options) {\n    const rerender = React__namespace.useReducer(()=>({}), {})[1];\n    const resolvedOptions = {\n        ...options,\n        onChange: (instance2, sync)=>{\n            var _a;\n            if (sync) {\n                reactDom.flushSync(rerender);\n            } else {\n                rerender();\n            }\n            (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);\n        }\n    };\n    const [instance] = React__namespace.useState(()=>new virtualCore.Virtualizer(resolvedOptions));\n    instance.setOptions(resolvedOptions);\n    React__namespace.useEffect(()=>{\n        return instance._didMount();\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        return instance._willUpdate();\n    });\n    return instance;\n}\nfunction useVirtualizer(options) {\n    return useVirtualizerBase({\n        observeElementRect: virtualCore.observeElementRect,\n        observeElementOffset: virtualCore.observeElementOffset,\n        scrollToFn: virtualCore.elementScroll,\n        ...options\n    });\n}\nfunction useWindowVirtualizer(options) {\n    return useVirtualizerBase({\n        getScrollElement: ()=>typeof document !== \"undefined\" ? window : null,\n        observeElementRect: virtualCore.observeWindowRect,\n        observeElementOffset: virtualCore.observeWindowOffset,\n        scrollToFn: virtualCore.windowScroll,\n        initialOffset: typeof document !== \"undefined\" ? window.scrollY : void 0,\n        ...options\n    });\n}\nexports.useVirtualizer = useVirtualizer;\nexports.useWindowVirtualizer = useWindowVirtualizer;\nObject.keys(virtualCore).forEach((k)=>{\n    if (k !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {\n        enumerable: true,\n        get: ()=>virtualCore[k]\n    });\n}); //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvZGlzdC9janMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLGNBQWMsQ0FBQ0MsU0FBU0MsT0FBT0MsV0FBVyxFQUFFO0lBQUVDLE9BQU87QUFBUztBQUNyRSxNQUFNQyxRQUFRQyxtQkFBT0EsQ0FBQyx3R0FBTztBQUM3QixNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxnSEFBVztBQUNwQyxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw4RkFBd0I7QUFDcEQsU0FBU0cseUJBQXlCQyxDQUFDO0lBQ2pDLE1BQU1DLElBQUlaLE9BQU9hLE1BQU0sQ0FBQyxNQUFNO1FBQUUsQ0FBQ1YsT0FBT0MsV0FBVyxDQUFDLEVBQUU7WUFBRUMsT0FBTztRQUFTO0lBQUU7SUFDMUUsSUFBSU0sR0FBRztRQUNMLElBQUssTUFBTUcsS0FBS0gsRUFBRztZQUNqQixJQUFJRyxNQUFNLFdBQVc7Z0JBQ25CLE1BQU1DLElBQUlmLE9BQU9nQix3QkFBd0IsQ0FBQ0wsR0FBR0c7Z0JBQzdDZCxPQUFPQyxjQUFjLENBQUNXLEdBQUdFLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtvQkFDdENHLFlBQVk7b0JBQ1pELEtBQUssSUFBTU4sQ0FBQyxDQUFDRyxFQUFFO2dCQUNqQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBRixFQUFFTyxPQUFPLEdBQUdSO0lBQ1osT0FBT1gsT0FBT29CLE1BQU0sQ0FBQ1I7QUFDdkI7QUFDQSxNQUFNUyxtQkFBbUIsYUFBYSxHQUFHWCx5QkFBeUJKO0FBQ2xFLE1BQU1nQiw0QkFBNEIsT0FBT0MsYUFBYSxjQUFjRixpQkFBaUJHLGVBQWUsR0FBR0gsaUJBQWlCSSxTQUFTO0FBQ2pJLFNBQVNDLG1CQUFtQkMsT0FBTztJQUNqQyxNQUFNQyxXQUFXUCxpQkFBaUJRLFVBQVUsQ0FBQyxJQUFPLEVBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0lBQy9ELE1BQU1DLGtCQUFrQjtRQUN0QixHQUFHSCxPQUFPO1FBQ1ZJLFVBQVUsQ0FBQ0MsV0FBV0M7WUFDcEIsSUFBSUM7WUFDSixJQUFJRCxNQUFNO2dCQUNSekIsU0FBUzJCLFNBQVMsQ0FBQ1A7WUFDckIsT0FBTztnQkFDTEE7WUFDRjtZQUNDTSxDQUFBQSxLQUFLUCxRQUFRSSxRQUFRLEtBQUssT0FBTyxLQUFLLElBQUlHLEdBQUdFLElBQUksQ0FBQ1QsU0FBU0ssV0FBV0M7UUFDekU7SUFDRjtJQUNBLE1BQU0sQ0FBQ0ksU0FBUyxHQUFHaEIsaUJBQWlCaUIsUUFBUSxDQUMxQyxJQUFNLElBQUk3QixZQUFZOEIsV0FBVyxDQUFDVDtJQUVwQ08sU0FBU0csVUFBVSxDQUFDVjtJQUNwQlQsaUJBQWlCSSxTQUFTLENBQUM7UUFDekIsT0FBT1ksU0FBU0ksU0FBUztJQUMzQixHQUFHLEVBQUU7SUFDTG5CLDBCQUEwQjtRQUN4QixPQUFPZSxTQUFTSyxXQUFXO0lBQzdCO0lBQ0EsT0FBT0w7QUFDVDtBQUNBLFNBQVNNLGVBQWVoQixPQUFPO0lBQzdCLE9BQU9ELG1CQUFtQjtRQUN4QmtCLG9CQUFvQm5DLFlBQVltQyxrQkFBa0I7UUFDbERDLHNCQUFzQnBDLFlBQVlvQyxvQkFBb0I7UUFDdERDLFlBQVlyQyxZQUFZc0MsYUFBYTtRQUNyQyxHQUFHcEIsT0FBTztJQUNaO0FBQ0Y7QUFDQSxTQUFTcUIscUJBQXFCckIsT0FBTztJQUNuQyxPQUFPRCxtQkFBbUI7UUFDeEJ1QixrQkFBa0IsSUFBTSxPQUFPMUIsYUFBYSxjQUFjMkIsU0FBUztRQUNuRU4sb0JBQW9CbkMsWUFBWTBDLGlCQUFpQjtRQUNqRE4sc0JBQXNCcEMsWUFBWTJDLG1CQUFtQjtRQUNyRE4sWUFBWXJDLFlBQVk0QyxZQUFZO1FBQ3BDQyxlQUFlLE9BQU8vQixhQUFhLGNBQWMyQixPQUFPSyxPQUFPLEdBQUcsS0FBSztRQUN2RSxHQUFHNUIsT0FBTztJQUNaO0FBQ0Y7QUFDQXpCLHNCQUFzQixHQUFHeUM7QUFDekJ6Qyw0QkFBNEIsR0FBRzhDO0FBQy9CaEQsT0FBT3dELElBQUksQ0FBQy9DLGFBQWFnRCxPQUFPLENBQUMsQ0FBQzNDO0lBQ2hDLElBQUlBLE1BQU0sYUFBYSxDQUFDZCxPQUFPMEQsU0FBUyxDQUFDQyxjQUFjLENBQUN2QixJQUFJLENBQUNsQyxTQUFTWSxJQUNwRWQsT0FBT0MsY0FBYyxDQUFDQyxTQUFTWSxHQUFHO1FBQ2hDSSxZQUFZO1FBQ1pELEtBQUssSUFBTVIsV0FBVyxDQUFDSyxFQUFFO0lBQzNCO0FBQ0osSUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3JsZHMtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9yZWFjdC12aXJ0dWFsL2Rpc3QvY2pzL2luZGV4LmNqcz9iZTNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KTtcbmNvbnN0IFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgcmVhY3REb20gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpO1xuY29uc3QgdmlydHVhbENvcmUgPSByZXF1aXJlKFwiQHRhbnN0YWNrL3ZpcnR1YWwtY29yZVwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gIGNvbnN0IG4gPSBPYmplY3QuY3JlYXRlKG51bGwsIHsgW1N5bWJvbC50b1N0cmluZ1RhZ106IHsgdmFsdWU6IFwiTW9kdWxlXCIgfSB9KTtcbiAgaWYgKGUpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gZSkge1xuICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIGNvbnN0IGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiAoKSA9PiBlW2tdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cbmNvbnN0IFJlYWN0X19uYW1lc3BhY2UgPSAvKiBAX19QVVJFX18gKi8gX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KFJlYWN0KTtcbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBSZWFjdF9fbmFtZXNwYWNlLnVzZUxheW91dEVmZmVjdCA6IFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0O1xuZnVuY3Rpb24gdXNlVmlydHVhbGl6ZXJCYXNlKG9wdGlvbnMpIHtcbiAgY29uc3QgcmVyZW5kZXIgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZHVjZXIoKCkgPT4gKHt9KSwge30pWzFdO1xuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBvbkNoYW5nZTogKGluc3RhbmNlMiwgc3luYykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgcmVhY3REb20uZmx1c2hTeW5jKHJlcmVuZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcmVuZGVyKCk7XG4gICAgICB9XG4gICAgICAoX2EgPSBvcHRpb25zLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBpbnN0YW5jZTIsIHN5bmMpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgW2luc3RhbmNlXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoXG4gICAgKCkgPT4gbmV3IHZpcnR1YWxDb3JlLlZpcnR1YWxpemVyKHJlc29sdmVkT3B0aW9ucylcbiAgKTtcbiAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhyZXNvbHZlZE9wdGlvbnMpO1xuICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9kaWRNb3VudCgpO1xuICB9LCBbXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBpbnN0YW5jZS5fd2lsbFVwZGF0ZSgpO1xuICB9KTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdXNlVmlydHVhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gdXNlVmlydHVhbGl6ZXJCYXNlKHtcbiAgICBvYnNlcnZlRWxlbWVudFJlY3Q6IHZpcnR1YWxDb3JlLm9ic2VydmVFbGVtZW50UmVjdCxcbiAgICBvYnNlcnZlRWxlbWVudE9mZnNldDogdmlydHVhbENvcmUub2JzZXJ2ZUVsZW1lbnRPZmZzZXQsXG4gICAgc2Nyb2xsVG9GbjogdmlydHVhbENvcmUuZWxlbWVudFNjcm9sbCxcbiAgICAuLi5vcHRpb25zXG4gIH0pO1xufVxuZnVuY3Rpb24gdXNlV2luZG93VmlydHVhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gdXNlVmlydHVhbGl6ZXJCYXNlKHtcbiAgICBnZXRTY3JvbGxFbGVtZW50OiAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBudWxsLFxuICAgIG9ic2VydmVFbGVtZW50UmVjdDogdmlydHVhbENvcmUub2JzZXJ2ZVdpbmRvd1JlY3QsXG4gICAgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQ6IHZpcnR1YWxDb3JlLm9ic2VydmVXaW5kb3dPZmZzZXQsXG4gICAgc2Nyb2xsVG9GbjogdmlydHVhbENvcmUud2luZG93U2Nyb2xsLFxuICAgIGluaXRpYWxPZmZzZXQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5zY3JvbGxZIDogdm9pZCAwLFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG59XG5leHBvcnRzLnVzZVZpcnR1YWxpemVyID0gdXNlVmlydHVhbGl6ZXI7XG5leHBvcnRzLnVzZVdpbmRvd1ZpcnR1YWxpemVyID0gdXNlV2luZG93VmlydHVhbGl6ZXI7XG5PYmplY3Qua2V5cyh2aXJ0dWFsQ29yZSkuZm9yRWFjaCgoaykgPT4ge1xuICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSlcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogKCkgPT4gdmlydHVhbENvcmVba11cbiAgICB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLm1hcFxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJSZWFjdCIsInJlcXVpcmUiLCJyZWFjdERvbSIsInZpcnR1YWxDb3JlIiwiX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0IiwiZSIsIm4iLCJjcmVhdGUiLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsImVudW1lcmFibGUiLCJkZWZhdWx0IiwiZnJlZXplIiwiUmVhY3RfX25hbWVzcGFjZSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJkb2N1bWVudCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZVZpcnR1YWxpemVyQmFzZSIsIm9wdGlvbnMiLCJyZXJlbmRlciIsInVzZVJlZHVjZXIiLCJyZXNvbHZlZE9wdGlvbnMiLCJvbkNoYW5nZSIsImluc3RhbmNlMiIsInN5bmMiLCJfYSIsImZsdXNoU3luYyIsImNhbGwiLCJpbnN0YW5jZSIsInVzZVN0YXRlIiwiVmlydHVhbGl6ZXIiLCJzZXRPcHRpb25zIiwiX2RpZE1vdW50IiwiX3dpbGxVcGRhdGUiLCJ1c2VWaXJ0dWFsaXplciIsIm9ic2VydmVFbGVtZW50UmVjdCIsIm9ic2VydmVFbGVtZW50T2Zmc2V0Iiwic2Nyb2xsVG9GbiIsImVsZW1lbnRTY3JvbGwiLCJ1c2VXaW5kb3dWaXJ0dWFsaXplciIsImdldFNjcm9sbEVsZW1lbnQiLCJ3aW5kb3ciLCJvYnNlcnZlV2luZG93UmVjdCIsIm9ic2VydmVXaW5kb3dPZmZzZXQiLCJ3aW5kb3dTY3JvbGwiLCJpbml0aWFsT2Zmc2V0Iiwic2Nyb2xsWSIsImtleXMiLCJmb3JFYWNoIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-virtual/dist/cjs/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/cjs/index.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/cjs/index.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, {\n    value: \"Module\"\n});\nconst utils = __webpack_require__(/*! ./utils.cjs */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/cjs/utils.cjs\");\nconst defaultKeyExtractor = (index)=>index;\nconst defaultRangeExtractor = (range)=>{\n    const start = Math.max(range.startIndex - range.overscan, 0);\n    const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n    const arr = [];\n    for(let i = start; i <= end; i++){\n        arr.push(i);\n    }\n    return arr;\n};\nconst observeElementRect = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = (rect)=>{\n        const { width, height } = rect;\n        cb({\n            width: Math.round(width),\n            height: Math.round(height)\n        });\n    };\n    handler(element.getBoundingClientRect());\n    if (typeof ResizeObserver === \"undefined\") {\n        return ()=>{};\n    }\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        if (entry == null ? void 0 : entry.borderBoxSize) {\n            const box = entry.borderBoxSize[0];\n            if (box) {\n                handler({\n                    width: box.inlineSize,\n                    height: box.blockSize\n                });\n                return;\n            }\n        }\n        handler(element.getBoundingClientRect());\n    });\n    observer.observe(element, {\n        box: \"border-box\"\n    });\n    return ()=>{\n        observer.unobserve(element);\n    };\n};\nconst observeWindowRect = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = ()=>{\n        cb({\n            width: element.innerWidth,\n            height: element.innerHeight\n        });\n    };\n    handler();\n    element.addEventListener(\"resize\", handler, {\n        passive: true\n    });\n    return ()=>{\n        element.removeEventListener(\"resize\", handler);\n    };\n};\nconst observeElementOffset = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = ()=>{\n        cb(element[instance.options.horizontal ? \"scrollLeft\" : \"scrollTop\"]);\n    };\n    handler();\n    element.addEventListener(\"scroll\", handler, {\n        passive: true\n    });\n    return ()=>{\n        element.removeEventListener(\"scroll\", handler);\n    };\n};\nconst observeWindowOffset = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = ()=>{\n        cb(element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"]);\n    };\n    handler();\n    element.addEventListener(\"scroll\", handler, {\n        passive: true\n    });\n    return ()=>{\n        element.removeEventListener(\"scroll\", handler);\n    };\n};\nconst measureElement = (element, entry, instance)=>{\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n            const size = Math.round(box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]);\n            return size;\n        }\n    }\n    return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]);\n};\nconst windowScroll = (offset, { adjustments = 0, behavior }, instance)=>{\n    var _a, _b;\n    const toOffset = offset + adjustments;\n    (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n        [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n        behavior\n    });\n};\nconst elementScroll = (offset, { adjustments = 0, behavior }, instance)=>{\n    var _a, _b;\n    const toOffset = offset + adjustments;\n    (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n        [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n        behavior\n    });\n};\nclass Virtualizer {\n    constructor(opts){\n        this.unsubs = [];\n        this.scrollElement = null;\n        this.isScrolling = false;\n        this.isScrollingTimeoutId = null;\n        this.scrollToIndexTimeoutId = null;\n        this.measurementsCache = [];\n        this.itemSizeCache = /* @__PURE__ */ new Map();\n        this.pendingMeasuredCacheIndexes = [];\n        this.scrollDirection = null;\n        this.scrollAdjustments = 0;\n        this.measureElementCache = /* @__PURE__ */ new Map();\n        this.observer = /* @__PURE__ */ (()=>{\n            let _ro = null;\n            const get = ()=>{\n                if (_ro) {\n                    return _ro;\n                } else if (typeof ResizeObserver !== \"undefined\") {\n                    return _ro = new ResizeObserver((entries)=>{\n                        entries.forEach((entry)=>{\n                            this._measureElement(entry.target, entry);\n                        });\n                    });\n                } else {\n                    return null;\n                }\n            };\n            return {\n                disconnect: ()=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.disconnect();\n                },\n                observe: (target)=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.observe(target, {\n                        box: \"border-box\"\n                    });\n                },\n                unobserve: (target)=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.unobserve(target);\n                }\n            };\n        })();\n        this.range = null;\n        this.setOptions = (opts2)=>{\n            Object.entries(opts2).forEach(([key, value])=>{\n                if (typeof value === \"undefined\") delete opts2[key];\n            });\n            this.options = {\n                debug: false,\n                initialOffset: 0,\n                overscan: 1,\n                paddingStart: 0,\n                paddingEnd: 0,\n                scrollPaddingStart: 0,\n                scrollPaddingEnd: 0,\n                horizontal: false,\n                getItemKey: defaultKeyExtractor,\n                rangeExtractor: defaultRangeExtractor,\n                onChange: ()=>{},\n                measureElement,\n                initialRect: {\n                    width: 0,\n                    height: 0\n                },\n                scrollMargin: 0,\n                scrollingDelay: 150,\n                indexAttribute: \"data-index\",\n                initialMeasurementsCache: [],\n                lanes: 1,\n                ...opts2\n            };\n        };\n        this.notify = (sync)=>{\n            var _a, _b;\n            (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n        };\n        this.maybeNotify = utils.memo(()=>{\n            this.calculateRange();\n            return [\n                this.isScrolling,\n                this.range ? this.range.startIndex : null,\n                this.range ? this.range.endIndex : null\n            ];\n        }, (isScrolling)=>{\n            this.notify(isScrolling);\n        }, {\n            key:  true && \"maybeNotify\",\n            debug: ()=>this.options.debug,\n            initialDeps: [\n                this.isScrolling,\n                this.range ? this.range.startIndex : null,\n                this.range ? this.range.endIndex : null\n            ]\n        });\n        this.cleanup = ()=>{\n            this.unsubs.filter(Boolean).forEach((d)=>d());\n            this.unsubs = [];\n            this.scrollElement = null;\n        };\n        this._didMount = ()=>{\n            this.measureElementCache.forEach(this.observer.observe);\n            return ()=>{\n                this.observer.disconnect();\n                this.cleanup();\n            };\n        };\n        this._willUpdate = ()=>{\n            const scrollElement = this.options.getScrollElement();\n            if (this.scrollElement !== scrollElement) {\n                this.cleanup();\n                this.scrollElement = scrollElement;\n                this._scrollToOffset(this.scrollOffset, {\n                    adjustments: void 0,\n                    behavior: void 0\n                });\n                this.unsubs.push(this.options.observeElementRect(this, (rect)=>{\n                    this.scrollRect = rect;\n                    this.maybeNotify();\n                }));\n                this.unsubs.push(this.options.observeElementOffset(this, (offset)=>{\n                    this.scrollAdjustments = 0;\n                    if (this.scrollOffset === offset) {\n                        return;\n                    }\n                    if (this.isScrollingTimeoutId !== null) {\n                        clearTimeout(this.isScrollingTimeoutId);\n                        this.isScrollingTimeoutId = null;\n                    }\n                    this.isScrolling = true;\n                    this.scrollDirection = this.scrollOffset < offset ? \"forward\" : \"backward\";\n                    this.scrollOffset = offset;\n                    this.maybeNotify();\n                    this.isScrollingTimeoutId = setTimeout(()=>{\n                        this.isScrollingTimeoutId = null;\n                        this.isScrolling = false;\n                        this.scrollDirection = null;\n                        this.maybeNotify();\n                    }, this.options.scrollingDelay);\n                }));\n            }\n        };\n        this.getSize = ()=>{\n            return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n        };\n        this.memoOptions = utils.memo(()=>[\n                this.options.count,\n                this.options.paddingStart,\n                this.options.scrollMargin,\n                this.options.getItemKey\n            ], (count, paddingStart, scrollMargin, getItemKey)=>{\n            this.pendingMeasuredCacheIndexes = [];\n            return {\n                count,\n                paddingStart,\n                scrollMargin,\n                getItemKey\n            };\n        }, {\n            key: false\n        });\n        this.getFurthestMeasurement = (measurements, index)=>{\n            const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n            const furthestMeasurements = /* @__PURE__ */ new Map();\n            for(let m = index - 1; m >= 0; m--){\n                const measurement = measurements[m];\n                if (furthestMeasurementsFound.has(measurement.lane)) {\n                    continue;\n                }\n                const previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);\n                if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n                    furthestMeasurements.set(measurement.lane, measurement);\n                } else if (measurement.end < previousFurthestMeasurement.end) {\n                    furthestMeasurementsFound.set(measurement.lane, true);\n                }\n                if (furthestMeasurementsFound.size === this.options.lanes) {\n                    break;\n                }\n            }\n            return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b)=>{\n                if (a.end === b.end) {\n                    return a.index - b.index;\n                }\n                return a.end - b.end;\n            })[0] : void 0;\n        };\n        this.getMeasurements = utils.memo(()=>[\n                this.memoOptions(),\n                this.itemSizeCache\n            ], ({ count, paddingStart, scrollMargin, getItemKey }, itemSizeCache)=>{\n            const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n            this.pendingMeasuredCacheIndexes = [];\n            const measurements = this.measurementsCache.slice(0, min);\n            for(let i = min; i < count; i++){\n                const key = getItemKey(i);\n                const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n                const start = furthestMeasurement ? furthestMeasurement.end : paddingStart + scrollMargin;\n                const measuredSize = itemSizeCache.get(key);\n                const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n                const end = start + size;\n                const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n                measurements[i] = {\n                    index: i,\n                    start,\n                    size,\n                    end,\n                    key,\n                    lane\n                };\n            }\n            this.measurementsCache = measurements;\n            return measurements;\n        }, {\n            key:  true && \"getMeasurements\",\n            debug: ()=>this.options.debug\n        });\n        this.calculateRange = utils.memo(()=>[\n                this.getMeasurements(),\n                this.getSize(),\n                this.scrollOffset\n            ], (measurements, outerSize, scrollOffset)=>{\n            return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n                measurements,\n                outerSize,\n                scrollOffset\n            }) : null;\n        }, {\n            key:  true && \"calculateRange\",\n            debug: ()=>this.options.debug\n        });\n        this.getIndexes = utils.memo(()=>[\n                this.options.rangeExtractor,\n                this.calculateRange(),\n                this.options.overscan,\n                this.options.count\n            ], (rangeExtractor, range, overscan, count)=>{\n            return range === null ? [] : rangeExtractor({\n                ...range,\n                overscan,\n                count\n            });\n        }, {\n            key:  true && \"getIndexes\",\n            debug: ()=>this.options.debug\n        });\n        this.indexFromElement = (node)=>{\n            const attributeName = this.options.indexAttribute;\n            const indexStr = node.getAttribute(attributeName);\n            if (!indexStr) {\n                console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`);\n                return -1;\n            }\n            return parseInt(indexStr, 10);\n        };\n        this._measureElement = (node, entry)=>{\n            const item = this.measurementsCache[this.indexFromElement(node)];\n            if (!item || !node.isConnected) {\n                this.measureElementCache.forEach((cached, key)=>{\n                    if (cached === node) {\n                        this.observer.unobserve(node);\n                        this.measureElementCache.delete(key);\n                    }\n                });\n                return;\n            }\n            const prevNode = this.measureElementCache.get(item.key);\n            if (prevNode !== node) {\n                if (prevNode) {\n                    this.observer.unobserve(prevNode);\n                }\n                this.observer.observe(node);\n                this.measureElementCache.set(item.key, node);\n            }\n            const measuredItemSize = this.options.measureElement(node, entry, this);\n            this.resizeItem(item, measuredItemSize);\n        };\n        this.resizeItem = (item, size)=>{\n            const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n            const delta = size - itemSize;\n            if (delta !== 0) {\n                if (item.start < this.scrollOffset + this.scrollAdjustments) {\n                    if ( true && this.options.debug) {\n                        console.info(\"correction\", delta);\n                    }\n                    this._scrollToOffset(this.scrollOffset, {\n                        adjustments: this.scrollAdjustments += delta,\n                        behavior: void 0\n                    });\n                }\n                this.pendingMeasuredCacheIndexes.push(item.index);\n                this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n                this.notify(false);\n            }\n        };\n        this.measureElement = (node)=>{\n            if (!node) {\n                return;\n            }\n            this._measureElement(node, void 0);\n        };\n        this.getVirtualItems = utils.memo(()=>[\n                this.getIndexes(),\n                this.getMeasurements()\n            ], (indexes, measurements)=>{\n            const virtualItems = [];\n            for(let k = 0, len = indexes.length; k < len; k++){\n                const i = indexes[k];\n                const measurement = measurements[i];\n                virtualItems.push(measurement);\n            }\n            return virtualItems;\n        }, {\n            key:  true && \"getIndexes\",\n            debug: ()=>this.options.debug\n        });\n        this.getVirtualItemForOffset = (offset)=>{\n            const measurements = this.getMeasurements();\n            return utils.notUndefined(measurements[findNearestBinarySearch(0, measurements.length - 1, (index)=>utils.notUndefined(measurements[index]).start, offset)]);\n        };\n        this.getOffsetForAlignment = (toOffset, align)=>{\n            const size = this.getSize();\n            if (align === \"auto\") {\n                if (toOffset <= this.scrollOffset) {\n                    align = \"start\";\n                } else if (toOffset >= this.scrollOffset + size) {\n                    align = \"end\";\n                } else {\n                    align = \"start\";\n                }\n            }\n            if (align === \"start\") {\n                toOffset = toOffset;\n            } else if (align === \"end\") {\n                toOffset = toOffset - size;\n            } else if (align === \"center\") {\n                toOffset = toOffset - size / 2;\n            }\n            const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n            const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n            const maxOffset = scrollSize - this.getSize();\n            return Math.max(Math.min(maxOffset, toOffset), 0);\n        };\n        this.getOffsetForIndex = (index, align = \"auto\")=>{\n            index = Math.max(0, Math.min(index, this.options.count - 1));\n            const measurement = utils.notUndefined(this.getMeasurements()[index]);\n            if (align === \"auto\") {\n                if (measurement.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) {\n                    align = \"end\";\n                } else if (measurement.start <= this.scrollOffset + this.options.scrollPaddingStart) {\n                    align = \"start\";\n                } else {\n                    return [\n                        this.scrollOffset,\n                        align\n                    ];\n                }\n            }\n            const toOffset = align === \"end\" ? measurement.end + this.options.scrollPaddingEnd : measurement.start - this.options.scrollPaddingStart;\n            return [\n                this.getOffsetForAlignment(toOffset, align),\n                align\n            ];\n        };\n        this.isDynamicMode = ()=>this.measureElementCache.size > 0;\n        this.cancelScrollToIndex = ()=>{\n            if (this.scrollToIndexTimeoutId !== null) {\n                clearTimeout(this.scrollToIndexTimeoutId);\n                this.scrollToIndexTimeoutId = null;\n            }\n        };\n        this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {})=>{\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n                adjustments: void 0,\n                behavior\n            });\n        };\n        this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {})=>{\n            index = Math.max(0, Math.min(index, this.options.count - 1));\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            const [toOffset, align] = this.getOffsetForIndex(index, initialAlign);\n            this._scrollToOffset(toOffset, {\n                adjustments: void 0,\n                behavior\n            });\n            if (behavior !== \"smooth\" && this.isDynamicMode()) {\n                this.scrollToIndexTimeoutId = setTimeout(()=>{\n                    this.scrollToIndexTimeoutId = null;\n                    const elementInDOM = this.measureElementCache.has(this.options.getItemKey(index));\n                    if (elementInDOM) {\n                        const [toOffset2] = this.getOffsetForIndex(index, align);\n                        if (!utils.approxEqual(toOffset2, this.scrollOffset)) {\n                            this.scrollToIndex(index, {\n                                align,\n                                behavior\n                            });\n                        }\n                    } else {\n                        this.scrollToIndex(index, {\n                            align,\n                            behavior\n                        });\n                    }\n                });\n            }\n        };\n        this.scrollBy = (delta, { behavior } = {})=>{\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            this._scrollToOffset(this.scrollOffset + delta, {\n                adjustments: void 0,\n                behavior\n            });\n        };\n        this.getTotalSize = ()=>{\n            var _a;\n            const measurements = this.getMeasurements();\n            let end;\n            if (measurements.length === 0) {\n                end = this.options.paddingStart;\n            } else {\n                end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(...measurements.slice(-this.options.lanes).map((m)=>m.end));\n            }\n            return end - this.options.scrollMargin + this.options.paddingEnd;\n        };\n        this._scrollToOffset = (offset, { adjustments, behavior })=>{\n            this.options.scrollToFn(offset, {\n                behavior,\n                adjustments\n            }, this);\n        };\n        this.measure = ()=>{\n            this.itemSizeCache = /* @__PURE__ */ new Map();\n            this.notify(false);\n        };\n        this.setOptions(opts);\n        this.scrollRect = this.options.initialRect;\n        this.scrollOffset = this.options.initialOffset;\n        this.measurementsCache = this.options.initialMeasurementsCache;\n        this.measurementsCache.forEach((item)=>{\n            this.itemSizeCache.set(item.key, item.size);\n        });\n        this.maybeNotify();\n    }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value)=>{\n    while(low <= high){\n        const middle = (low + high) / 2 | 0;\n        const currentValue = getCurrentValue(middle);\n        if (currentValue < value) {\n            low = middle + 1;\n        } else if (currentValue > value) {\n            high = middle - 1;\n        } else {\n            return middle;\n        }\n    }\n    if (low > 0) {\n        return low - 1;\n    } else {\n        return 0;\n    }\n};\nfunction calculateRange({ measurements, outerSize, scrollOffset }) {\n    const count = measurements.length - 1;\n    const getOffset = (index)=>measurements[index].start;\n    const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n    let endIndex = startIndex;\n    while(endIndex < count && measurements[endIndex].end < scrollOffset + outerSize){\n        endIndex++;\n    }\n    return {\n        startIndex,\n        endIndex\n    };\n}\nexports.approxEqual = utils.approxEqual;\nexports.memo = utils.memo;\nexports.notUndefined = utils.notUndefined;\nexports.Virtualizer = Virtualizer;\nexports.defaultKeyExtractor = defaultKeyExtractor;\nexports.defaultRangeExtractor = defaultRangeExtractor;\nexports.elementScroll = elementScroll;\nexports.measureElement = measureElement;\nexports.observeElementOffset = observeElementOffset;\nexports.observeElementRect = observeElementRect;\nexports.observeWindowOffset = observeWindowOffset;\nexports.observeWindowRect = observeWindowRect;\nexports.windowScroll = windowScroll; //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2Nqcy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsY0FBYyxDQUFDQyxTQUFTQyxPQUFPQyxXQUFXLEVBQUU7SUFBRUMsT0FBTztBQUFTO0FBQ3JFLE1BQU1DLFFBQVFDLG1CQUFPQSxDQUFDLG1GQUFhO0FBQ25DLE1BQU1DLHNCQUFzQixDQUFDQyxRQUFVQTtBQUN2QyxNQUFNQyx3QkFBd0IsQ0FBQ0M7SUFDN0IsTUFBTUMsUUFBUUMsS0FBS0MsR0FBRyxDQUFDSCxNQUFNSSxVQUFVLEdBQUdKLE1BQU1LLFFBQVEsRUFBRTtJQUMxRCxNQUFNQyxNQUFNSixLQUFLSyxHQUFHLENBQUNQLE1BQU1RLFFBQVEsR0FBR1IsTUFBTUssUUFBUSxFQUFFTCxNQUFNUyxLQUFLLEdBQUc7SUFDcEUsTUFBTUMsTUFBTSxFQUFFO0lBQ2QsSUFBSyxJQUFJQyxJQUFJVixPQUFPVSxLQUFLTCxLQUFLSyxJQUFLO1FBQ2pDRCxJQUFJRSxJQUFJLENBQUNEO0lBQ1g7SUFDQSxPQUFPRDtBQUNUO0FBQ0EsTUFBTUcscUJBQXFCLENBQUNDLFVBQVVDO0lBQ3BDLE1BQU1DLFVBQVVGLFNBQVNHLGFBQWE7SUFDdEMsSUFBSSxDQUFDRCxTQUFTO1FBQ1o7SUFDRjtJQUNBLE1BQU1FLFVBQVUsQ0FBQ0M7UUFDZixNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdGO1FBQzFCSixHQUFHO1lBQUVLLE9BQU9sQixLQUFLb0IsS0FBSyxDQUFDRjtZQUFRQyxRQUFRbkIsS0FBS29CLEtBQUssQ0FBQ0Q7UUFBUTtJQUM1RDtJQUNBSCxRQUFRRixRQUFRTyxxQkFBcUI7SUFDckMsSUFBSSxPQUFPQyxtQkFBbUIsYUFBYTtRQUN6QyxPQUFPLEtBQ1A7SUFDRjtJQUNBLE1BQU1DLFdBQVcsSUFBSUQsZUFBZSxDQUFDRTtRQUNuQyxNQUFNQyxRQUFRRCxPQUFPLENBQUMsRUFB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QVdKO0lBQ2YsTUFBT0ksV0FBV0MsU0FBUzJHLFlBQVksQ0FBQzVHLFNBQVMsQ0FBQ0YsR0FBRyxHQUFHdUcsZUFBZTRCLFVBQVc7UUFDaEZqSTtJQUNGO0lBQ0EsT0FBTztRQUFFSjtRQUFZSTtJQUFTO0FBQ2hDO0FBQ0FqQixtQkFBbUIsR0FBR0ksTUFBTXlMLFdBQVc7QUFDdkM3TCxZQUFZLEdBQUdJLE1BQU1zRyxJQUFJO0FBQ3pCMUcsb0JBQW9CLEdBQUdJLE1BQU13SyxZQUFZO0FBQ3pDNUssbUJBQW1CLEdBQUdpRTtBQUN0QmpFLDJCQUEyQixHQUFHTTtBQUM5Qk4sNkJBQTZCLEdBQUdRO0FBQ2hDUixxQkFBcUIsR0FBR2dFO0FBQ3hCaEUsc0JBQXNCLEdBQUdxRDtBQUN6QnJELDRCQUE0QixHQUFHaUQ7QUFDL0JqRCwwQkFBMEIsR0FBR3NCO0FBQzdCdEIsMkJBQTJCLEdBQUdvRDtBQUM5QnBELHlCQUF5QixHQUFHMkM7QUFDNUIzQyxvQkFBb0IsR0FBR3VELGNBQ3ZCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmxkcy1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2Nqcy9pbmRleC5janM/OTY2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmNqc1wiKTtcbmNvbnN0IGRlZmF1bHRLZXlFeHRyYWN0b3IgPSAoaW5kZXgpID0+IGluZGV4O1xuY29uc3QgZGVmYXVsdFJhbmdlRXh0cmFjdG9yID0gKHJhbmdlKSA9PiB7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnRJbmRleCAtIHJhbmdlLm92ZXJzY2FuLCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ocmFuZ2UuZW5kSW5kZXggKyByYW5nZS5vdmVyc2NhbiwgcmFuZ2UuY291bnQgLSAxKTtcbiAgY29uc3QgYXJyID0gW107XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgIGFyci5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuY29uc3Qgb2JzZXJ2ZUVsZW1lbnRSZWN0ID0gKGluc3RhbmNlLCBjYikgPT4ge1xuICBjb25zdCBlbGVtZW50ID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhhbmRsZXIgPSAocmVjdCkgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmVjdDtcbiAgICBjYih7IHdpZHRoOiBNYXRoLnJvdW5kKHdpZHRoKSwgaGVpZ2h0OiBNYXRoLnJvdW5kKGhlaWdodCkgfSk7XG4gIH07XG4gIGhhbmRsZXIoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgaWYgKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeS5ib3JkZXJCb3hTaXplKSB7XG4gICAgICBjb25zdCBib3ggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdO1xuICAgICAgaWYgKGJveCkge1xuICAgICAgICBoYW5kbGVyKHsgd2lkdGg6IGJveC5pbmxpbmVTaXplLCBoZWlnaHQ6IGJveC5ibG9ja1NpemUgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlcihlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwgeyBib3g6IFwiYm9yZGVyLWJveFwiIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgfTtcbn07XG5jb25zdCBvYnNlcnZlV2luZG93UmVjdCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgIGNiKHsgd2lkdGg6IGVsZW1lbnQuaW5uZXJXaWR0aCwgaGVpZ2h0OiBlbGVtZW50LmlubmVySGVpZ2h0IH0pO1xuICB9O1xuICBoYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVyLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlcik7XG4gIH07XG59O1xuY29uc3Qgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICBjYihlbGVtZW50W2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIl0pO1xuICB9O1xuICBoYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gIH07XG59O1xuY29uc3Qgb2JzZXJ2ZVdpbmRvd09mZnNldCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgIGNiKGVsZW1lbnRbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJzY3JvbGxYXCIgOiBcInNjcm9sbFlcIl0pO1xuICB9O1xuICBoYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gIH07XG59O1xuY29uc3QgbWVhc3VyZUVsZW1lbnQgPSAoZWxlbWVudCwgZW50cnksIGluc3RhbmNlKSA9PiB7XG4gIGlmIChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuYm9yZGVyQm94U2l6ZSkge1xuICAgIGNvbnN0IGJveCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF07XG4gICAgaWYgKGJveCkge1xuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgucm91bmQoXG4gICAgICAgIGJveFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImlubGluZVNpemVcIiA6IFwiYmxvY2tTaXplXCJdXG4gICAgICApO1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKFxuICAgIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl1cbiAgKTtcbn07XG5jb25zdCB3aW5kb3dTY3JvbGwgPSAob2Zmc2V0LCB7XG4gIGFkanVzdG1lbnRzID0gMCxcbiAgYmVoYXZpb3Jcbn0sIGluc3RhbmNlKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHRvT2Zmc2V0ID0gb2Zmc2V0ICsgYWRqdXN0bWVudHM7XG4gIChfYiA9IChfYSA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY3JvbGxUbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICBbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJsZWZ0XCIgOiBcInRvcFwiXTogdG9PZmZzZXQsXG4gICAgYmVoYXZpb3JcbiAgfSk7XG59O1xuY29uc3QgZWxlbWVudFNjcm9sbCA9IChvZmZzZXQsIHtcbiAgYWRqdXN0bWVudHMgPSAwLFxuICBiZWhhdmlvclxufSwgaW5zdGFuY2UpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgdG9PZmZzZXQgPSBvZmZzZXQgKyBhZGp1c3RtZW50cztcbiAgKF9iID0gKF9hID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNjcm9sbFRvKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgIFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImxlZnRcIiA6IFwidG9wXCJdOiB0b09mZnNldCxcbiAgICBiZWhhdmlvclxuICB9KTtcbn07XG5jbGFzcyBWaXJ0dWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnVuc3VicyA9IFtdO1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTY3JvbGxpbmdUaW1lb3V0SWQgPSBudWxsO1xuICAgIHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IG51bGw7XG4gICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IFtdO1xuICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXTtcbiAgICB0aGlzLnNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zY3JvbGxBZGp1c3RtZW50cyA9IDA7XG4gICAgdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm9ic2VydmVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgICBsZXQgX3JvID0gbnVsbDtcbiAgICAgIGNvbnN0IGdldCA9ICgpID0+IHtcbiAgICAgICAgaWYgKF9ybykge1xuICAgICAgICAgIHJldHVybiBfcm87XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIF9ybyA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudChlbnRyeS50YXJnZXQsIGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICByZXR1cm4gKF9hID0gZ2V0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9ic2VydmU6ICh0YXJnZXQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIChfYSA9IGdldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2Eub2JzZXJ2ZSh0YXJnZXQsIHsgYm94OiBcImJvcmRlci1ib3hcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5vYnNlcnZlOiAodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgdGhpcy5yYW5nZSA9IG51bGw7XG4gICAgdGhpcy5zZXRPcHRpb25zID0gKG9wdHMyKSA9PiB7XG4gICAgICBPYmplY3QuZW50cmllcyhvcHRzMikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgZGVsZXRlIG9wdHMyW2tleV07XG4gICAgICB9KTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBpbml0aWFsT2Zmc2V0OiAwLFxuICAgICAgICBvdmVyc2NhbjogMSxcbiAgICAgICAgcGFkZGluZ1N0YXJ0OiAwLFxuICAgICAgICBwYWRkaW5nRW5kOiAwLFxuICAgICAgICBzY3JvbGxQYWRkaW5nU3RhcnQ6IDAsXG4gICAgICAgIHNjcm9sbFBhZGRpbmdFbmQ6IDAsXG4gICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICBnZXRJdGVtS2V5OiBkZWZhdWx0S2V5RXh0cmFjdG9yLFxuICAgICAgICByYW5nZUV4dHJhY3RvcjogZGVmYXVsdFJhbmdlRXh0cmFjdG9yLFxuICAgICAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICBtZWFzdXJlRWxlbWVudCxcbiAgICAgICAgaW5pdGlhbFJlY3Q6IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LFxuICAgICAgICBzY3JvbGxNYXJnaW46IDAsXG4gICAgICAgIHNjcm9sbGluZ0RlbGF5OiAxNTAsXG4gICAgICAgIGluZGV4QXR0cmlidXRlOiBcImRhdGEtaW5kZXhcIixcbiAgICAgICAgaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlOiBbXSxcbiAgICAgICAgbGFuZXM6IDEsXG4gICAgICAgIC4uLm9wdHMyXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5ub3RpZnkgPSAoc3luYykgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucykub25DaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aGlzLCBzeW5jKTtcbiAgICB9O1xuICAgIHRoaXMubWF5YmVOb3RpZnkgPSB1dGlscy5tZW1vKFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVJhbmdlKCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdGhpcy5pc1Njcm9sbGluZyxcbiAgICAgICAgICB0aGlzLnJhbmdlID8gdGhpcy5yYW5nZS5zdGFydEluZGV4IDogbnVsbCxcbiAgICAgICAgICB0aGlzLnJhbmdlID8gdGhpcy5yYW5nZS5lbmRJbmRleCA6IG51bGxcbiAgICAgICAgXTtcbiAgICAgIH0sXG4gICAgICAoaXNTY3JvbGxpbmcpID0+IHtcbiAgICAgICAgdGhpcy5ub3RpZnkoaXNTY3JvbGxpbmcpO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgXCJtYXliZU5vdGlmeVwiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnLFxuICAgICAgICBpbml0aWFsRGVwczogW1xuICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcsXG4gICAgICAgICAgdGhpcy5yYW5nZSA/IHRoaXMucmFuZ2Uuc3RhcnRJbmRleCA6IG51bGwsXG4gICAgICAgICAgdGhpcy5yYW5nZSA/IHRoaXMucmFuZ2UuZW5kSW5kZXggOiBudWxsXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuY2xlYW51cCA9ICgpID0+IHtcbiAgICAgIHRoaXMudW5zdWJzLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKChkKSA9PiBkKCkpO1xuICAgICAgdGhpcy51bnN1YnMgPSBbXTtcbiAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gICAgfTtcbiAgICB0aGlzLl9kaWRNb3VudCA9ICgpID0+IHtcbiAgICAgIHRoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5mb3JFYWNoKHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5fd2lsbFVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSB0aGlzLm9wdGlvbnMuZ2V0U2Nyb2xsRWxlbWVudCgpO1xuICAgICAgaWYgKHRoaXMuc2Nyb2xsRWxlbWVudCAhPT0gc2Nyb2xsRWxlbWVudCkge1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5zY3JvbGxPZmZzZXQsIHtcbiAgICAgICAgICBhZGp1c3RtZW50czogdm9pZCAwLFxuICAgICAgICAgIGJlaGF2aW9yOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW5zdWJzLnB1c2goXG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9ic2VydmVFbGVtZW50UmVjdCh0aGlzLCAocmVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgIHRoaXMubWF5YmVOb3RpZnkoKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnVuc3Vicy5wdXNoKFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5vYnNlcnZlRWxlbWVudE9mZnNldCh0aGlzLCAob2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFkanVzdG1lbnRzID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbE9mZnNldCA9PT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2Nyb2xsaW5nVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlzU2Nyb2xsaW5nVGltZW91dElkKTtcbiAgICAgICAgICAgICAgdGhpcy5pc1Njcm9sbGluZ1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gdGhpcy5zY3JvbGxPZmZzZXQgPCBvZmZzZXQgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIjtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5tYXliZU5vdGlmeSgpO1xuICAgICAgICAgICAgdGhpcy5pc1Njcm9sbGluZ1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aGlzLnNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMubWF5YmVOb3RpZnkoKTtcbiAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5zY3JvbGxpbmdEZWxheSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbFJlY3RbdGhpcy5vcHRpb25zLmhvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXTtcbiAgICB9O1xuICAgIHRoaXMubWVtb09wdGlvbnMgPSB1dGlscy5tZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0aGlzLm9wdGlvbnMuY291bnQsXG4gICAgICAgIHRoaXMub3B0aW9ucy5wYWRkaW5nU3RhcnQsXG4gICAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxNYXJnaW4sXG4gICAgICAgIHRoaXMub3B0aW9ucy5nZXRJdGVtS2V5XG4gICAgICBdLFxuICAgICAgKGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSkgPT4ge1xuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvdW50LFxuICAgICAgICAgIHBhZGRpbmdTdGFydCxcbiAgICAgICAgICBzY3JvbGxNYXJnaW4sXG4gICAgICAgICAgZ2V0SXRlbUtleVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBmYWxzZVxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5nZXRGdXJ0aGVzdE1lYXN1cmVtZW50ID0gKG1lYXN1cmVtZW50cywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgZnVydGhlc3RNZWFzdXJlbWVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChsZXQgbSA9IGluZGV4IC0gMTsgbSA+PSAwOyBtLS0pIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbbV07XG4gICAgICAgIGlmIChmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kLmhhcyhtZWFzdXJlbWVudC5sYW5lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudCA9IGZ1cnRoZXN0TWVhc3VyZW1lbnRzLmdldChcbiAgICAgICAgICBtZWFzdXJlbWVudC5sYW5lXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQgPT0gbnVsbCB8fCBtZWFzdXJlbWVudC5lbmQgPiBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQuZW5kKSB7XG4gICAgICAgICAgZnVydGhlc3RNZWFzdXJlbWVudHMuc2V0KG1lYXN1cmVtZW50LmxhbmUsIG1lYXN1cmVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChtZWFzdXJlbWVudC5lbmQgPCBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQuZW5kKSB7XG4gICAgICAgICAgZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5zZXQobWVhc3VyZW1lbnQubGFuZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuc2l6ZSA9PT0gdGhpcy5vcHRpb25zLmxhbmVzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdXJ0aGVzdE1lYXN1cmVtZW50cy5zaXplID09PSB0aGlzLm9wdGlvbnMubGFuZXMgPyBBcnJheS5mcm9tKGZ1cnRoZXN0TWVhc3VyZW1lbnRzLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLmVuZCA9PT0gYi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuZW5kIC0gYi5lbmQ7XG4gICAgICB9KVswXSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TWVhc3VyZW1lbnRzID0gdXRpbHMubWVtbyhcbiAgICAgICgpID0+IFt0aGlzLm1lbW9PcHRpb25zKCksIHRoaXMuaXRlbVNpemVDYWNoZV0sXG4gICAgICAoeyBjb3VudCwgcGFkZGluZ1N0YXJ0LCBzY3JvbGxNYXJnaW4sIGdldEl0ZW1LZXkgfSwgaXRlbVNpemVDYWNoZSkgPT4ge1xuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcy5sZW5ndGggPiAwID8gTWF0aC5taW4oLi4udGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMpIDogMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbWVhc3VyZW1lbnRzID0gdGhpcy5tZWFzdXJlbWVudHNDYWNoZS5zbGljZSgwLCBtaW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gbWluOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGdldEl0ZW1LZXkoaSk7XG4gICAgICAgICAgY29uc3QgZnVydGhlc3RNZWFzdXJlbWVudCA9IHRoaXMub3B0aW9ucy5sYW5lcyA9PT0gMSA/IG1lYXN1cmVtZW50c1tpIC0gMV0gOiB0aGlzLmdldEZ1cnRoZXN0TWVhc3VyZW1lbnQobWVhc3VyZW1lbnRzLCBpKTtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPyBmdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCA6IHBhZGRpbmdTdGFydCArIHNjcm9sbE1hcmdpbjtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlZFNpemUgPSBpdGVtU2l6ZUNhY2hlLmdldChrZXkpO1xuICAgICAgICAgIGNvbnN0IHNpemUgPSB0eXBlb2YgbWVhc3VyZWRTaXplID09PSBcIm51bWJlclwiID8gbWVhc3VyZWRTaXplIDogdGhpcy5vcHRpb25zLmVzdGltYXRlU2l6ZShpKTtcbiAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHNpemU7XG4gICAgICAgICAgY29uc3QgbGFuZSA9IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPyBmdXJ0aGVzdE1lYXN1cmVtZW50LmxhbmUgOiBpICUgdGhpcy5vcHRpb25zLmxhbmVzO1xuICAgICAgICAgIG1lYXN1cmVtZW50c1tpXSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbGFuZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IG1lYXN1cmVtZW50cztcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVtZW50cztcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0TWVhc3VyZW1lbnRzXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuY2FsY3VsYXRlUmFuZ2UgPSB1dGlscy5tZW1vKFxuICAgICAgKCkgPT4gW3RoaXMuZ2V0TWVhc3VyZW1lbnRzKCksIHRoaXMuZ2V0U2l6ZSgpLCB0aGlzLnNjcm9sbE9mZnNldF0sXG4gICAgICAobWVhc3VyZW1lbnRzLCBvdXRlclNpemUsIHNjcm9sbE9mZnNldCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZSA9IG1lYXN1cmVtZW50cy5sZW5ndGggPiAwICYmIG91dGVyU2l6ZSA+IDAgPyBjYWxjdWxhdGVSYW5nZSh7XG4gICAgICAgICAgbWVhc3VyZW1lbnRzLFxuICAgICAgICAgIG91dGVyU2l6ZSxcbiAgICAgICAgICBzY3JvbGxPZmZzZXRcbiAgICAgICAgfSkgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgXCJjYWxjdWxhdGVSYW5nZVwiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmdldEluZGV4ZXMgPSB1dGlscy5tZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0aGlzLm9wdGlvbnMucmFuZ2VFeHRyYWN0b3IsXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUmFuZ2UoKSxcbiAgICAgICAgdGhpcy5vcHRpb25zLm92ZXJzY2FuLFxuICAgICAgICB0aGlzLm9wdGlvbnMuY291bnRcbiAgICAgIF0sXG4gICAgICAocmFuZ2VFeHRyYWN0b3IsIHJhbmdlLCBvdmVyc2NhbiwgY291bnQpID0+IHtcbiAgICAgICAgcmV0dXJuIHJhbmdlID09PSBudWxsID8gW10gOiByYW5nZUV4dHJhY3Rvcih7XG4gICAgICAgICAgLi4ucmFuZ2UsXG4gICAgICAgICAgb3ZlcnNjYW4sXG4gICAgICAgICAgY291bnRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImdldEluZGV4ZXNcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1Z1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5pbmRleEZyb21FbGVtZW50ID0gKG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLm9wdGlvbnMuaW5kZXhBdHRyaWJ1dGU7XG4gICAgICBjb25zdCBpbmRleFN0ciA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgaWYgKCFpbmRleFN0cikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYE1pc3NpbmcgYXR0cmlidXRlIG5hbWUgJyR7YXR0cmlidXRlTmFtZX09e2luZGV4fScgb24gbWVhc3VyZWQgZWxlbWVudC5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUludChpbmRleFN0ciwgMTApO1xuICAgIH07XG4gICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQgPSAobm9kZSwgZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlW3RoaXMuaW5kZXhGcm9tRWxlbWVudChub2RlKV07XG4gICAgICBpZiAoIWl0ZW0gfHwgIW5vZGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLmZvckVhY2goKGNhY2hlZCwga2V5KSA9PiB7XG4gICAgICAgICAgaWYgKGNhY2hlZCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci51bm9ic2VydmUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldk5vZGUgPSB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuZ2V0KGl0ZW0ua2V5KTtcbiAgICAgIGlmIChwcmV2Tm9kZSAhPT0gbm9kZSkge1xuICAgICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVyLnVub2JzZXJ2ZShwcmV2Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKG5vZGUpO1xuICAgICAgICB0aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuc2V0KGl0ZW0ua2V5LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lYXN1cmVkSXRlbVNpemUgPSB0aGlzLm9wdGlvbnMubWVhc3VyZUVsZW1lbnQobm9kZSwgZW50cnksIHRoaXMpO1xuICAgICAgdGhpcy5yZXNpemVJdGVtKGl0ZW0sIG1lYXN1cmVkSXRlbVNpemUpO1xuICAgIH07XG4gICAgdGhpcy5yZXNpemVJdGVtID0gKGl0ZW0sIHNpemUpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZUNhY2hlLmdldChpdGVtLmtleSkgPz8gaXRlbS5zaXplO1xuICAgICAgY29uc3QgZGVsdGEgPSBzaXplIC0gaXRlbVNpemU7XG4gICAgICBpZiAoZGVsdGEgIT09IDApIHtcbiAgICAgICAgaWYgKGl0ZW0uc3RhcnQgPCB0aGlzLnNjcm9sbE9mZnNldCArIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiY29ycmVjdGlvblwiLCBkZWx0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuc2Nyb2xsT2Zmc2V0LCB7XG4gICAgICAgICAgICBhZGp1c3RtZW50czogdGhpcy5zY3JvbGxBZGp1c3RtZW50cyArPSBkZWx0YSxcbiAgICAgICAgICAgIGJlaGF2aW9yOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcy5wdXNoKGl0ZW0uaW5kZXgpO1xuICAgICAgICB0aGlzLml0ZW1TaXplQ2FjaGUgPSBuZXcgTWFwKHRoaXMuaXRlbVNpemVDYWNoZS5zZXQoaXRlbS5rZXksIHNpemUpKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tZWFzdXJlRWxlbWVudCA9IChub2RlKSA9PiB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQobm9kZSwgdm9pZCAwKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VmlydHVhbEl0ZW1zID0gdXRpbHMubWVtbyhcbiAgICAgICgpID0+IFt0aGlzLmdldEluZGV4ZXMoKSwgdGhpcy5nZXRNZWFzdXJlbWVudHMoKV0sXG4gICAgICAoaW5kZXhlcywgbWVhc3VyZW1lbnRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZpcnR1YWxJdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrID0gMCwgbGVuID0gaW5kZXhlcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgIGNvbnN0IGkgPSBpbmRleGVzW2tdO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgICAgICAgIHZpcnR1YWxJdGVtcy5wdXNoKG1lYXN1cmVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlydHVhbEl0ZW1zO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgXCJnZXRJbmRleGVzXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZ2V0VmlydHVhbEl0ZW1Gb3JPZmZzZXQgPSAob2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLmdldE1lYXN1cmVtZW50cygpO1xuICAgICAgcmV0dXJuIHV0aWxzLm5vdFVuZGVmaW5lZChcbiAgICAgICAgbWVhc3VyZW1lbnRzW2ZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgKGluZGV4KSA9PiB1dGlscy5ub3RVbmRlZmluZWQobWVhc3VyZW1lbnRzW2luZGV4XSkuc3RhcnQsXG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgICldXG4gICAgICApO1xuICAgIH07XG4gICAgdGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQgPSAodG9PZmZzZXQsIGFsaWduKSA9PiB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICBpZiAoYWxpZ24gPT09IFwiYXV0b1wiKSB7XG4gICAgICAgIGlmICh0b09mZnNldCA8PSB0aGlzLnNjcm9sbE9mZnNldCkge1xuICAgICAgICAgIGFsaWduID0gXCJzdGFydFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRvT2Zmc2V0ID49IHRoaXMuc2Nyb2xsT2Zmc2V0ICsgc2l6ZSkge1xuICAgICAgICAgIGFsaWduID0gXCJlbmRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGlnbiA9IFwic3RhcnRcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFsaWduID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgdG9PZmZzZXQgPSB0b09mZnNldDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwiZW5kXCIpIHtcbiAgICAgICAgdG9PZmZzZXQgPSB0b09mZnNldCAtIHNpemU7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgIHRvT2Zmc2V0ID0gdG9PZmZzZXQgLSBzaXplIC8gMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjcm9sbFNpemVQcm9wID0gdGhpcy5vcHRpb25zLmhvcml6b250YWwgPyBcInNjcm9sbFdpZHRoXCIgOiBcInNjcm9sbEhlaWdodFwiO1xuICAgICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IHRoaXMuc2Nyb2xsRWxlbWVudCA/IFwiZG9jdW1lbnRcIiBpbiB0aGlzLnNjcm9sbEVsZW1lbnQgPyB0aGlzLnNjcm9sbEVsZW1lbnQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W3Njcm9sbFNpemVQcm9wXSA6IHRoaXMuc2Nyb2xsRWxlbWVudFtzY3JvbGxTaXplUHJvcF0gOiAwO1xuICAgICAgY29uc3QgbWF4T2Zmc2V0ID0gc2Nyb2xsU2l6ZSAtIHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKG1heE9mZnNldCwgdG9PZmZzZXQpLCAwKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T2Zmc2V0Rm9ySW5kZXggPSAoaW5kZXgsIGFsaWduID0gXCJhdXRvXCIpID0+IHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMub3B0aW9ucy5jb3VudCAtIDEpKTtcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gdXRpbHMubm90VW5kZWZpbmVkKHRoaXMuZ2V0TWVhc3VyZW1lbnRzKClbaW5kZXhdKTtcbiAgICAgIGlmIChhbGlnbiA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVtZW50LmVuZCA+PSB0aGlzLnNjcm9sbE9mZnNldCArIHRoaXMuZ2V0U2l6ZSgpIC0gdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdFbmQpIHtcbiAgICAgICAgICBhbGlnbiA9IFwiZW5kXCI7XG4gICAgICAgIH0gZWxzZSBpZiAobWVhc3VyZW1lbnQuc3RhcnQgPD0gdGhpcy5zY3JvbGxPZmZzZXQgKyB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ1N0YXJ0KSB7XG4gICAgICAgICAgYWxpZ24gPSBcInN0YXJ0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFt0aGlzLnNjcm9sbE9mZnNldCwgYWxpZ25dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0b09mZnNldCA9IGFsaWduID09PSBcImVuZFwiID8gbWVhc3VyZW1lbnQuZW5kICsgdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdFbmQgOiBtZWFzdXJlbWVudC5zdGFydCAtIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nU3RhcnQ7XG4gICAgICByZXR1cm4gW3RoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50KHRvT2Zmc2V0LCBhbGlnbiksIGFsaWduXTtcbiAgICB9O1xuICAgIHRoaXMuaXNEeW5hbWljTW9kZSA9ICgpID0+IHRoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5zaXplID4gMDtcbiAgICB0aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXggPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zY3JvbGxUb09mZnNldCA9ICh0b09mZnNldCwgeyBhbGlnbiA9IFwic3RhcnRcIiwgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICB0aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXgoKTtcbiAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJzbW9vdGhcIiAmJiB0aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50KHRvT2Zmc2V0LCBhbGlnbiksIHtcbiAgICAgICAgYWRqdXN0bWVudHM6IHZvaWQgMCxcbiAgICAgICAgYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5zY3JvbGxUb0luZGV4ID0gKGluZGV4LCB7IGFsaWduOiBpbml0aWFsQWxpZ24gPSBcImF1dG9cIiwgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLm9wdGlvbnMuY291bnQgLSAxKSk7XG4gICAgICB0aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXgoKTtcbiAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJzbW9vdGhcIiAmJiB0aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFt0b09mZnNldCwgYWxpZ25dID0gdGhpcy5nZXRPZmZzZXRGb3JJbmRleChpbmRleCwgaW5pdGlhbEFsaWduKTtcbiAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRvT2Zmc2V0LCB7IGFkanVzdG1lbnRzOiB2b2lkIDAsIGJlaGF2aW9yIH0pO1xuICAgICAgaWYgKGJlaGF2aW9yICE9PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgY29uc3QgZWxlbWVudEluRE9NID0gdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLmhhcyhcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5nZXRJdGVtS2V5KGluZGV4KVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGVsZW1lbnRJbkRPTSkge1xuICAgICAgICAgICAgY29uc3QgW3RvT2Zmc2V0Ml0gPSB0aGlzLmdldE9mZnNldEZvckluZGV4KGluZGV4LCBhbGlnbik7XG4gICAgICAgICAgICBpZiAoIXV0aWxzLmFwcHJveEVxdWFsKHRvT2Zmc2V0MiwgdGhpcy5zY3JvbGxPZmZzZXQpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChpbmRleCwgeyBhbGlnbiwgYmVoYXZpb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChpbmRleCwgeyBhbGlnbiwgYmVoYXZpb3IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsQnkgPSAoZGVsdGEsIHsgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICB0aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXgoKTtcbiAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJzbW9vdGhcIiAmJiB0aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuc2Nyb2xsT2Zmc2V0ICsgZGVsdGEsIHtcbiAgICAgICAgYWRqdXN0bWVudHM6IHZvaWQgMCxcbiAgICAgICAgYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5nZXRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLmdldE1lYXN1cmVtZW50cygpO1xuICAgICAgbGV0IGVuZDtcbiAgICAgIGlmIChtZWFzdXJlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGVuZCA9IHRoaXMub3B0aW9ucy5wYWRkaW5nU3RhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSB0aGlzLm9wdGlvbnMubGFuZXMgPT09IDEgPyAoKF9hID0gbWVhc3VyZW1lbnRzW21lYXN1cmVtZW50cy5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmVuZCkgPz8gMCA6IE1hdGgubWF4KFxuICAgICAgICAgIC4uLm1lYXN1cmVtZW50cy5zbGljZSgtdGhpcy5vcHRpb25zLmxhbmVzKS5tYXAoKG0pID0+IG0uZW5kKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuZCAtIHRoaXMub3B0aW9ucy5zY3JvbGxNYXJnaW4gKyB0aGlzLm9wdGlvbnMucGFkZGluZ0VuZDtcbiAgICB9O1xuICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0ID0gKG9mZnNldCwge1xuICAgICAgYWRqdXN0bWVudHMsXG4gICAgICBiZWhhdmlvclxuICAgIH0pID0+IHtcbiAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxUb0ZuKG9mZnNldCwgeyBiZWhhdmlvciwgYWRqdXN0bWVudHMgfSwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLml0ZW1TaXplQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5ub3RpZnkoZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdHMpO1xuICAgIHRoaXMuc2Nyb2xsUmVjdCA9IHRoaXMub3B0aW9ucy5pbml0aWFsUmVjdDtcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHRoaXMub3B0aW9ucy5pbml0aWFsT2Zmc2V0O1xuICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSB0aGlzLm9wdGlvbnMuaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlO1xuICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlLnNldChpdGVtLmtleSwgaXRlbS5zaXplKTtcbiAgICB9KTtcbiAgICB0aGlzLm1heWJlTm90aWZ5KCk7XG4gIH1cbn1cbmNvbnN0IGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoID0gKGxvdywgaGlnaCwgZ2V0Q3VycmVudFZhbHVlLCB2YWx1ZSkgPT4ge1xuICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICBjb25zdCBtaWRkbGUgPSAobG93ICsgaGlnaCkgLyAyIHwgMDtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBnZXRDdXJyZW50VmFsdWUobWlkZGxlKTtcbiAgICBpZiAoY3VycmVudFZhbHVlIDwgdmFsdWUpIHtcbiAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUgPiB2YWx1ZSkge1xuICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgfVxuICB9XG4gIGlmIChsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGxvdyAtIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVSYW5nZSh7XG4gIG1lYXN1cmVtZW50cyxcbiAgb3V0ZXJTaXplLFxuICBzY3JvbGxPZmZzZXRcbn0pIHtcbiAgY29uc3QgY291bnQgPSBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMTtcbiAgY29uc3QgZ2V0T2Zmc2V0ID0gKGluZGV4KSA9PiBtZWFzdXJlbWVudHNbaW5kZXhdLnN0YXJ0O1xuICBjb25zdCBzdGFydEluZGV4ID0gZmluZE5lYXJlc3RCaW5hcnlTZWFyY2goMCwgY291bnQsIGdldE9mZnNldCwgc2Nyb2xsT2Zmc2V0KTtcbiAgbGV0IGVuZEluZGV4ID0gc3RhcnRJbmRleDtcbiAgd2hpbGUgKGVuZEluZGV4IDwgY291bnQgJiYgbWVhc3VyZW1lbnRzW2VuZEluZGV4XS5lbmQgPCBzY3JvbGxPZmZzZXQgKyBvdXRlclNpemUpIHtcbiAgICBlbmRJbmRleCsrO1xuICB9XG4gIHJldHVybiB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4IH07XG59XG5leHBvcnRzLmFwcHJveEVxdWFsID0gdXRpbHMuYXBwcm94RXF1YWw7XG5leHBvcnRzLm1lbW8gPSB1dGlscy5tZW1vO1xuZXhwb3J0cy5ub3RVbmRlZmluZWQgPSB1dGlscy5ub3RVbmRlZmluZWQ7XG5leHBvcnRzLlZpcnR1YWxpemVyID0gVmlydHVhbGl6ZXI7XG5leHBvcnRzLmRlZmF1bHRLZXlFeHRyYWN0b3IgPSBkZWZhdWx0S2V5RXh0cmFjdG9yO1xuZXhwb3J0cy5kZWZhdWx0UmFuZ2VFeHRyYWN0b3IgPSBkZWZhdWx0UmFuZ2VFeHRyYWN0b3I7XG5leHBvcnRzLmVsZW1lbnRTY3JvbGwgPSBlbGVtZW50U2Nyb2xsO1xuZXhwb3J0cy5tZWFzdXJlRWxlbWVudCA9IG1lYXN1cmVFbGVtZW50O1xuZXhwb3J0cy5vYnNlcnZlRWxlbWVudE9mZnNldCA9IG9ic2VydmVFbGVtZW50T2Zmc2V0O1xuZXhwb3J0cy5vYnNlcnZlRWxlbWVudFJlY3QgPSBvYnNlcnZlRWxlbWVudFJlY3Q7XG5leHBvcnRzLm9ic2VydmVXaW5kb3dPZmZzZXQgPSBvYnNlcnZlV2luZG93T2Zmc2V0O1xuZXhwb3J0cy5vYnNlcnZlV2luZG93UmVjdCA9IG9ic2VydmVXaW5kb3dSZWN0O1xuZXhwb3J0cy53aW5kb3dTY3JvbGwgPSB3aW5kb3dTY3JvbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInV0aWxzIiwicmVxdWlyZSIsImRlZmF1bHRLZXlFeHRyYWN0b3IiLCJpbmRleCIsImRlZmF1bHRSYW5nZUV4dHJhY3RvciIsInJhbmdlIiwic3RhcnQiLCJNYXRoIiwibWF4Iiwic3RhcnRJbmRleCIsIm92ZXJzY2FuIiwiZW5kIiwibWluIiwiZW5kSW5kZXgiLCJjb3VudCIsImFyciIsImkiLCJwdXNoIiwib2JzZXJ2ZUVsZW1lbnRSZWN0IiwiaW5zdGFuY2UiLCJjYiIsImVsZW1lbnQiLCJzY3JvbGxFbGVtZW50IiwiaGFuZGxlciIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCIsInJvdW5kIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlciIsImVudHJpZXMiLCJlbnRyeSIsImJvcmRlckJveFNpemUiLCJib3giLCJpbmxpbmVTaXplIiwiYmxvY2tTaXplIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsIm9ic2VydmVXaW5kb3dSZWN0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2JzZXJ2ZUVsZW1lbnRPZmZzZXQiLCJvcHRpb25zIiwiaG9yaXpvbnRhbCIsIm9ic2VydmVXaW5kb3dPZmZzZXQiLCJtZWFzdXJlRWxlbWVudCIsInNpemUiLCJ3aW5kb3dTY3JvbGwiLCJvZmZzZXQiLCJhZGp1c3RtZW50cyIsImJlaGF2aW9yIiwiX2EiLCJfYiIsInRvT2Zmc2V0Iiwic2Nyb2xsVG8iLCJjYWxsIiwiZWxlbWVudFNjcm9sbCIsIlZpcnR1YWxpemVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwidW5zdWJzIiwiaXNTY3JvbGxpbmciLCJpc1Njcm9sbGluZ1RpbWVvdXRJZCIsInNjcm9sbFRvSW5kZXhUaW1lb3V0SWQiLCJtZWFzdXJlbWVudHNDYWNoZSIsIml0ZW1TaXplQ2FjaGUiLCJNYXAiLCJwZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMiLCJzY3JvbGxEaXJlY3Rpb24iLCJzY3JvbGxBZGp1c3RtZW50cyIsIm1lYXN1cmVFbGVtZW50Q2FjaGUiLCJfcm8iLCJnZXQiLCJmb3JFYWNoIiwiX21lYXN1cmVFbGVtZW50IiwidGFyZ2V0IiwiZGlzY29ubmVjdCIsInNldE9wdGlvbnMiLCJvcHRzMiIsImtleSIsImRlYnVnIiwiaW5pdGlhbE9mZnNldCIsInBhZGRpbmdTdGFydCIsInBhZGRpbmdFbmQiLCJzY3JvbGxQYWRkaW5nU3RhcnQiLCJzY3JvbGxQYWRkaW5nRW5kIiwiZ2V0SXRlbUtleSIsInJhbmdlRXh0cmFjdG9yIiwib25DaGFuZ2UiLCJpbml0aWFsUmVjdCIsInNjcm9sbE1hcmdpbiIsInNjcm9sbGluZ0RlbGF5IiwiaW5kZXhBdHRyaWJ1dGUiLCJpbml0aWFsTWVhc3VyZW1lbnRzQ2FjaGUiLCJsYW5lcyIsIm5vdGlmeSIsInN5bmMiLCJtYXliZU5vdGlmeSIsIm1lbW8iLCJjYWxjdWxhdGVSYW5nZSIsInByb2Nlc3MiLCJpbml0aWFsRGVwcyIsImNsZWFudXAiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZCIsIl9kaWRNb3VudCIsIl93aWxsVXBkYXRlIiwiZ2V0U2Nyb2xsRWxlbWVudCIsIl9zY3JvbGxUb09mZnNldCIsInNjcm9sbE9mZnNldCIsInNjcm9sbFJlY3QiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZ2V0U2l6ZSIsIm1lbW9PcHRpb25zIiwiZ2V0RnVydGhlc3RNZWFzdXJlbWVudCIsIm1lYXN1cmVtZW50cyIsImZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQiLCJmdXJ0aGVzdE1lYXN1cmVtZW50cyIsIm0iLCJtZWFzdXJlbWVudCIsImhhcyIsImxhbmUiLCJwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQiLCJzZXQiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJzb3J0IiwiYSIsImIiLCJnZXRNZWFzdXJlbWVudHMiLCJsZW5ndGgiLCJzbGljZSIsImZ1cnRoZXN0TWVhc3VyZW1lbnQiLCJtZWFzdXJlZFNpemUiLCJlc3RpbWF0ZVNpemUiLCJvdXRlclNpemUiLCJnZXRJbmRleGVzIiwiaW5kZXhGcm9tRWxlbWVudCIsIm5vZGUiLCJhdHRyaWJ1dGVOYW1lIiwiaW5kZXhTdHIiLCJnZXRBdHRyaWJ1dGUiLCJjb25zb2xlIiwid2FybiIsInBhcnNlSW50IiwiaXRlbSIsImlzQ29ubmVjdGVkIiwiY2FjaGVkIiwiZGVsZXRlIiwicHJldk5vZGUiLCJtZWFzdXJlZEl0ZW1TaXplIiwicmVzaXplSXRlbSIsIml0ZW1TaXplIiwiZGVsdGEiLCJpbmZvIiwiZ2V0VmlydHVhbEl0ZW1zIiwiaW5kZXhlcyIsInZpcnR1YWxJdGVtcyIsImsiLCJsZW4iLCJnZXRWaXJ0dWFsSXRlbUZvck9mZnNldCIsIm5vdFVuZGVmaW5lZCIsImZpbmROZWFyZXN0QmluYXJ5U2VhcmNoIiwiZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50IiwiYWxpZ24iLCJzY3JvbGxTaXplUHJvcCIsInNjcm9sbFNpemUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsIm1heE9mZnNldCIsImdldE9mZnNldEZvckluZGV4IiwiaXNEeW5hbWljTW9kZSIsImNhbmNlbFNjcm9sbFRvSW5kZXgiLCJzY3JvbGxUb09mZnNldCIsInNjcm9sbFRvSW5kZXgiLCJpbml0aWFsQWxpZ24iLCJlbGVtZW50SW5ET00iLCJ0b09mZnNldDIiLCJhcHByb3hFcXVhbCIsInNjcm9sbEJ5IiwiZ2V0VG90YWxTaXplIiwibWFwIiwic2Nyb2xsVG9GbiIsIm1lYXN1cmUiLCJsb3ciLCJoaWdoIiwiZ2V0Q3VycmVudFZhbHVlIiwibWlkZGxlIiwiY3VycmVudFZhbHVlIiwiZ2V0T2Zmc2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/cjs/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/cjs/utils.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/cjs/utils.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, {\n    value: \"Module\"\n});\nfunction memo(getDeps, fn, opts) {\n    let deps = opts.initialDeps ?? [];\n    let result;\n    return ()=>{\n        var _a, _b, _c, _d;\n        let depTime;\n        if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n        const newDeps = getDeps();\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n        result = fn(...newDeps);\n        if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n            const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n            const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n            const resultFpsPercentage = resultEndTime / 16;\n            const pad = (str, num)=>{\n                str = String(str);\n                while(str.length < num){\n                    str = \" \" + str;\n                }\n                return str;\n            };\n            console.info(`%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n        }\n        (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n        return result;\n    };\n}\nfunction notUndefined(value, msg) {\n    if (value === void 0) {\n        throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n    } else {\n        return value;\n    }\n}\nconst approxEqual = (a, b)=>Math.abs(a - b) < 1;\nexports.approxEqual = approxEqual;\nexports.memo = memo;\nexports.notUndefined = notUndefined; //# sourceMappingURL=utils.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2Nqcy91dGlscy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsY0FBYyxDQUFDQyxTQUFTQyxPQUFPQyxXQUFXLEVBQUU7SUFBRUMsT0FBTztBQUFTO0FBQ3JFLFNBQVNDLEtBQUtDLE9BQU8sRUFBRUMsRUFBRSxFQUFFQyxJQUFJO0lBQzdCLElBQUlDLE9BQU9ELEtBQUtFLFdBQVcsSUFBSSxFQUFFO0lBQ2pDLElBQUlDO0lBQ0osT0FBTztRQUNMLElBQUlDLElBQUlDLElBQUlDLElBQUlDO1FBQ2hCLElBQUlDO1FBQ0osSUFBSVIsS0FBS1MsR0FBRyxJQUFLLEVBQUNMLEtBQUtKLEtBQUtVLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSU4sR0FBR08sSUFBSSxDQUFDWCxLQUFJLEdBQ2hFUSxVQUFVSSxLQUFLQyxHQUFHO1FBQ3BCLE1BQU1DLFVBQVVoQjtRQUNoQixNQUFNaUIsY0FBY0QsUUFBUUUsTUFBTSxLQUFLZixLQUFLZSxNQUFNLElBQUlGLFFBQVFHLElBQUksQ0FBQyxDQUFDQyxLQUFLQyxRQUFVbEIsSUFBSSxDQUFDa0IsTUFBTSxLQUFLRDtRQUNuRyxJQUFJLENBQUNILGFBQWE7WUFDaEIsT0FBT1o7UUFDVDtRQUNBRixPQUFPYTtRQUNQLElBQUlNO1FBQ0osSUFBSXBCLEtBQUtTLEdBQUcsSUFBSyxFQUFDSixLQUFLTCxLQUFLVSxLQUFLLEtBQUssT0FBTyxLQUFLLElBQUlMLEdBQUdNLElBQUksQ0FBQ1gsS0FBSSxHQUNoRW9CLGFBQWFSLEtBQUtDLEdBQUc7UUFDdkJWLFNBQVNKLE1BQU1lO1FBQ2YsSUFBSWQsS0FBS1MsR0FBRyxJQUFLLEVBQUNILEtBQUtOLEtBQUtVLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSUosR0FBR0ssSUFBSSxDQUFDWCxLQUFJLEdBQUk7WUFDcEUsTUFBTXFCLGFBQWFDLEtBQUtDLEtBQUssQ0FBQyxDQUFDWCxLQUFLQyxHQUFHLEtBQUtMLE9BQU0sSUFBSyxPQUFPO1lBQzlELE1BQU1nQixnQkFBZ0JGLEtBQUtDLEtBQUssQ0FBQyxDQUFDWCxLQUFLQyxHQUFHLEtBQUtPLFVBQVMsSUFBSyxPQUFPO1lBQ3BFLE1BQU1LLHNCQUFzQkQsZ0JBQWdCO1lBQzVDLE1BQU1FLE1BQU0sQ0FBQ0MsS0FBS0M7Z0JBQ2hCRCxNQUFNRSxPQUFPRjtnQkFDYixNQUFPQSxJQUFJWCxNQUFNLEdBQUdZLElBQUs7b0JBQ3ZCRCxNQUFNLE1BQU1BO2dCQUNkO2dCQUNBLE9BQU9BO1lBQ1Q7WUFDQUcsUUFBUUMsSUFBSSxDQUNWLENBQUMsSUFBSSxFQUFFTCxJQUFJRixlQUFlLEdBQUcsRUFBRSxFQUFFRSxJQUFJTCxZQUFZLEdBQUcsR0FBRyxDQUFDLEVBQ3hELENBQUM7Ozt1QkFHYyxFQUFFQyxLQUFLVSxHQUFHLENBQ3ZCLEdBQ0FWLEtBQUtXLEdBQUcsQ0FBQyxNQUFNLE1BQU1SLHFCQUFxQixNQUMxQyxjQUFjLENBQUMsRUFDakJ6QixRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLUyxHQUFHO1FBRXBDO1FBQ0NGLENBQUFBLEtBQUtQLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtrQyxRQUFRLEtBQUssT0FBTyxLQUFLLElBQUkzQixHQUFHSSxJQUFJLENBQUNYLE1BQU1HO1FBQzlFLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLFNBQVNnQyxhQUFhdkMsS0FBSyxFQUFFd0MsR0FBRztJQUM5QixJQUFJeEMsVUFBVSxLQUFLLEdBQUc7UUFDcEIsTUFBTSxJQUFJeUMsTUFBTSxDQUFDLG9CQUFvQixFQUFFRCxNQUFNLENBQUMsRUFBRSxFQUFFQSxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDaEUsT0FBTztRQUNMLE9BQU94QztJQUNUO0FBQ0Y7QUFDQSxNQUFNMEMsY0FBYyxDQUFDQyxHQUFHQyxJQUFNbEIsS0FBS21CLEdBQUcsQ0FBQ0YsSUFBSUMsS0FBSztBQUNoRC9DLG1CQUFtQixHQUFHNkM7QUFDdEI3QyxZQUFZLEdBQUdJO0FBQ2ZKLG9CQUFvQixHQUFHMEMsY0FDdkIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ybGRzLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2Rpc3QvY2pzL3V0aWxzLmNqcz85NmM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KTtcbmZ1bmN0aW9uIG1lbW8oZ2V0RGVwcywgZm4sIG9wdHMpIHtcbiAgbGV0IGRlcHMgPSBvcHRzLmluaXRpYWxEZXBzID8/IFtdO1xuICBsZXQgcmVzdWx0O1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBsZXQgZGVwVGltZTtcbiAgICBpZiAob3B0cy5rZXkgJiYgKChfYSA9IG9wdHMuZGVidWcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdHMpKSlcbiAgICAgIGRlcFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG5ld0RlcHMgPSBnZXREZXBzKCk7XG4gICAgY29uc3QgZGVwc0NoYW5nZWQgPSBuZXdEZXBzLmxlbmd0aCAhPT0gZGVwcy5sZW5ndGggfHwgbmV3RGVwcy5zb21lKChkZXAsIGluZGV4KSA9PiBkZXBzW2luZGV4XSAhPT0gZGVwKTtcbiAgICBpZiAoIWRlcHNDaGFuZ2VkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBkZXBzID0gbmV3RGVwcztcbiAgICBsZXQgcmVzdWx0VGltZTtcbiAgICBpZiAob3B0cy5rZXkgJiYgKChfYiA9IG9wdHMuZGVidWcpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKG9wdHMpKSlcbiAgICAgIHJlc3VsdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJlc3VsdCA9IGZuKC4uLm5ld0RlcHMpO1xuICAgIGlmIChvcHRzLmtleSAmJiAoKF9jID0gb3B0cy5kZWJ1ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwob3B0cykpKSB7XG4gICAgICBjb25zdCBkZXBFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIGRlcFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgIGNvbnN0IHJlc3VsdEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gcmVzdWx0VGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgY29uc3QgcmVzdWx0RnBzUGVyY2VudGFnZSA9IHJlc3VsdEVuZFRpbWUgLyAxNjtcbiAgICAgIGNvbnN0IHBhZCA9IChzdHIsIG51bSkgPT4ge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBudW0pIHtcbiAgICAgICAgICBzdHIgPSBcIiBcIiArIHN0cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfTtcbiAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgYCVj4o+xICR7cGFkKHJlc3VsdEVuZFRpbWUsIDUpfSAvJHtwYWQoZGVwRW5kVGltZSwgNSl9IG1zYCxcbiAgICAgICAgYFxuICAgICAgICAgICAgZm9udC1zaXplOiAuNnJlbTtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgY29sb3I6IGhzbCgke01hdGgubWF4KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgTWF0aC5taW4oMTIwIC0gMTIwICogcmVzdWx0RnBzUGVyY2VudGFnZSwgMTIwKVxuICAgICAgICApfWRlZyAxMDAlIDMxJSk7YCxcbiAgICAgICAgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5rZXlcbiAgICAgICk7XG4gICAgfVxuICAgIChfZCA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMub25DaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWxsKG9wdHMsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vdFVuZGVmaW5lZCh2YWx1ZSwgbXNnKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHVuZGVmaW5lZCR7bXNnID8gYDogJHttc2d9YCA6IFwiXCJ9YCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5jb25zdCBhcHByb3hFcXVhbCA9IChhLCBiKSA9PiBNYXRoLmFicyhhIC0gYikgPCAxO1xuZXhwb3J0cy5hcHByb3hFcXVhbCA9IGFwcHJveEVxdWFsO1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMubm90VW5kZWZpbmVkID0gbm90VW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuY2pzLm1hcFxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJtZW1vIiwiZ2V0RGVwcyIsImZuIiwib3B0cyIsImRlcHMiLCJpbml0aWFsRGVwcyIsInJlc3VsdCIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiZGVwVGltZSIsImtleSIsImRlYnVnIiwiY2FsbCIsIkRhdGUiLCJub3ciLCJuZXdEZXBzIiwiZGVwc0NoYW5nZWQiLCJsZW5ndGgiLCJzb21lIiwiZGVwIiwiaW5kZXgiLCJyZXN1bHRUaW1lIiwiZGVwRW5kVGltZSIsIk1hdGgiLCJyb3VuZCIsInJlc3VsdEVuZFRpbWUiLCJyZXN1bHRGcHNQZXJjZW50YWdlIiwicGFkIiwic3RyIiwibnVtIiwiU3RyaW5nIiwiY29uc29sZSIsImluZm8iLCJtYXgiLCJtaW4iLCJvbkNoYW5nZSIsIm5vdFVuZGVmaW5lZCIsIm1zZyIsIkVycm9yIiwiYXBwcm94RXF1YWwiLCJhIiwiYiIsImFicyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/cjs/utils.cjs\n");

/***/ })

};
;