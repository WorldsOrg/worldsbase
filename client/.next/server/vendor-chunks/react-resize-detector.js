"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-resize-detector";
exports.ids = ["vendor-chunks/react-resize-detector"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-resize-detector/build/index.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-resize-detector/build/index.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ResizeDetector),\n/* harmony export */   useResizeDetector: () => (/* binding */ useResizeDetector),\n/* harmony export */   withResizeDetector: () => (/* binding */ withResizeDetector)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n\n\n /******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ \n/* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {}; /**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */ \nfunction isObject$3(value) {\n    var type = typeof value;\n    return value != null && (type == \"object\" || type == \"function\");\n}\nvar isObject_1 = isObject$3; /** Detect free variable `global` from Node.js. */ \nvar freeGlobal$1 = typeof commonjsGlobal == \"object\" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\nvar _freeGlobal = freeGlobal$1;\nvar freeGlobal = _freeGlobal;\n/** Detect free variable `self`. */ var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n/** Used as a reference to the global object. */ var root$2 = freeGlobal || freeSelf || Function(\"return this\")();\nvar _root = root$2;\nvar root$1 = _root;\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */ var now$1 = function() {\n    return root$1.Date.now();\n};\nvar now_1 = now$1; /** Used to match a single whitespace character. */ \nvar reWhitespace = /\\s/;\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */ function trimmedEndIndex$1(string) {\n    var index = string.length;\n    while(index-- && reWhitespace.test(string.charAt(index))){}\n    return index;\n}\nvar _trimmedEndIndex = trimmedEndIndex$1;\nvar trimmedEndIndex = _trimmedEndIndex;\n/** Used to match leading whitespace. */ var reTrimStart = /^\\s+/;\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */ function baseTrim$1(string) {\n    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, \"\") : string;\n}\nvar _baseTrim = baseTrim$1;\nvar root = _root;\n/** Built-in value references. */ var Symbol$2 = root.Symbol;\nvar _Symbol = Symbol$2;\nvar Symbol$1 = _Symbol;\n/** Used for built-in method references. */ var objectProto$1 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty = objectProto$1.hasOwnProperty;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var nativeObjectToString$1 = objectProto$1.toString;\n/** Built-in value references. */ var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */ function getRawTag$1(value) {\n    var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];\n    try {\n        value[symToStringTag$1] = undefined;\n        var unmasked = true;\n    } catch (e) {}\n    var result = nativeObjectToString$1.call(value);\n    if (unmasked) {\n        if (isOwn) {\n            value[symToStringTag$1] = tag;\n        } else {\n            delete value[symToStringTag$1];\n        }\n    }\n    return result;\n}\nvar _getRawTag = getRawTag$1; /** Used for built-in method references. */ \nvar objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var nativeObjectToString = objectProto.toString;\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */ function objectToString$1(value) {\n    return nativeObjectToString.call(value);\n}\nvar _objectToString = objectToString$1;\nvar Symbol = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;\n/** `Object#toString` result references. */ var nullTag = \"[object Null]\", undefinedTag = \"[object Undefined]\";\n/** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */ function baseGetTag$1(value) {\n    if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n    }\n    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\nvar _baseGetTag = baseGetTag$1; /**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */ \nfunction isObjectLike$1(value) {\n    return value != null && typeof value == \"object\";\n}\nvar isObjectLike_1 = isObjectLike$1;\nvar baseGetTag = _baseGetTag, isObjectLike = isObjectLike_1;\n/** `Object#toString` result references. */ var symbolTag = \"[object Symbol]\";\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */ function isSymbol$1(value) {\n    return typeof value == \"symbol\" || isObjectLike(value) && baseGetTag(value) == symbolTag;\n}\nvar isSymbol_1 = isSymbol$1;\nvar baseTrim = _baseTrim, isObject$2 = isObject_1, isSymbol = isSymbol_1;\n/** Used as references for various `Number` constants. */ var NAN = 0 / 0;\n/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;\n/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;\n/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */ function toNumber$1(value) {\n    if (typeof value == \"number\") {\n        return value;\n    }\n    if (isSymbol(value)) {\n        return NAN;\n    }\n    if (isObject$2(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject$2(other) ? other + \"\" : other;\n    }\n    if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n    }\n    value = baseTrim(value);\n    var isBinary = reIsBinary.test(value);\n    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\nvar toNumber_1 = toNumber$1;\nvar isObject$1 = isObject_1, now = now_1, toNumber = toNumber_1;\n/** Error message constants. */ var FUNC_ERROR_TEXT$1 = \"Expected a function\";\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */ function debounce$1(func, wait, options) {\n    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n    if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT$1);\n    }\n    wait = toNumber(wait) || 0;\n    if (isObject$1(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n    }\n    function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) {\n            clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n    }\n    function debounced() {\n        var time = now(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                // Handle invocations in a tight loop.\n                clearTimeout(timerId);\n                timerId = setTimeout(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n}\nvar debounce_1 = debounce$1;\nvar debounce = debounce_1, isObject = isObject_1;\n/** Error message constants. */ var FUNC_ERROR_TEXT = \"Expected a function\";\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */ function throttle(func, wait, options) {\n    var leading = true, trailing = true;\n    if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    if (isObject(options)) {\n        leading = \"leading\" in options ? !!options.leading : leading;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    return debounce(func, wait, {\n        \"leading\": leading,\n        \"maxWait\": wait,\n        \"trailing\": trailing\n    });\n}\nvar throttle_1 = throttle;\nvar patchResizeHandler = function(resizeCallback, refreshMode, refreshRate, refreshOptions) {\n    switch(refreshMode){\n        case \"debounce\":\n            return debounce_1(resizeCallback, refreshRate, refreshOptions);\n        case \"throttle\":\n            return throttle_1(resizeCallback, refreshRate, refreshOptions);\n        default:\n            return resizeCallback;\n    }\n};\nvar isFunction = function(fn) {\n    return typeof fn === \"function\";\n};\nvar isSSR = function() {\n    return \"undefined\" === \"undefined\";\n};\nvar isDOMElement = function(element) {\n    return element instanceof Element || element instanceof HTMLDocument;\n};\nvar createNotifier = function(onResize, setSize, handleWidth, handleHeight) {\n    return function(_a) {\n        var width = _a.width, height = _a.height;\n        setSize(function(prev) {\n            if (prev.width === width && prev.height === height) {\n                // skip if dimensions haven't changed\n                return prev;\n            }\n            if (prev.width === width && !handleHeight || prev.height === height && !handleWidth) {\n                // process `handleHeight/handleWidth` props\n                return prev;\n            }\n            if (onResize && isFunction(onResize)) {\n                onResize(width, height);\n            }\n            return {\n                width: width,\n                height: height\n            };\n        });\n    };\n};\nvar ResizeDetector = /** @class */ function(_super) {\n    __extends(ResizeDetector, _super);\n    function ResizeDetector(props) {\n        var _this = _super.call(this, props) || this;\n        _this.cancelHandler = function() {\n            if (_this.resizeHandler && _this.resizeHandler.cancel) {\n                // cancel debounced handler\n                _this.resizeHandler.cancel();\n                _this.resizeHandler = null;\n            }\n        };\n        _this.attachObserver = function() {\n            var _a = _this.props, targetRef = _a.targetRef, observerOptions = _a.observerOptions;\n            if (isSSR()) {\n                return;\n            }\n            if (targetRef && targetRef.current) {\n                _this.targetRef.current = targetRef.current;\n            }\n            var element = _this.getElement();\n            if (!element) {\n                // can't find element to observe\n                return;\n            }\n            if (_this.observableElement && _this.observableElement === element) {\n                // element is already observed\n                return;\n            }\n            _this.observableElement = element;\n            _this.resizeObserver.observe(element, observerOptions);\n        };\n        _this.getElement = function() {\n            var _a = _this.props, querySelector = _a.querySelector, targetDomEl = _a.targetDomEl;\n            if (isSSR()) return null;\n            // in case we pass a querySelector\n            if (querySelector) return document.querySelector(querySelector);\n            // in case we pass a DOM element\n            if (targetDomEl && isDOMElement(targetDomEl)) return targetDomEl;\n            // in case we pass a React ref using React.createRef()\n            if (_this.targetRef && isDOMElement(_this.targetRef.current)) return _this.targetRef.current;\n            // the worse case when we don't receive any information from the parent and the library doesn't add any wrappers\n            // we have to use a deprecated `findDOMNode` method in order to find a DOM element to attach to\n            var currentElement = (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.findDOMNode)(_this);\n            if (!currentElement) return null;\n            var renderType = _this.getRenderType();\n            switch(renderType){\n                case \"renderProp\":\n                    return currentElement;\n                case \"childFunction\":\n                    return currentElement;\n                case \"child\":\n                    return currentElement;\n                case \"childArray\":\n                    return currentElement;\n                default:\n                    return currentElement.parentElement;\n            }\n        };\n        _this.createResizeHandler = function(entries) {\n            var _a = _this.props, _b = _a.handleWidth, handleWidth = _b === void 0 ? true : _b, _c = _a.handleHeight, handleHeight = _c === void 0 ? true : _c, onResize = _a.onResize;\n            if (!handleWidth && !handleHeight) return;\n            var notifyResize = createNotifier(onResize, _this.setState.bind(_this), handleWidth, handleHeight);\n            entries.forEach(function(entry) {\n                var _a = entry && entry.contentRect || {}, width = _a.width, height = _a.height;\n                var shouldSetSize = !_this.skipOnMount && !isSSR();\n                if (shouldSetSize) {\n                    notifyResize({\n                        width: width,\n                        height: height\n                    });\n                }\n                _this.skipOnMount = false;\n            });\n        };\n        _this.getRenderType = function() {\n            var _a = _this.props, render = _a.render, children = _a.children;\n            if (isFunction(render)) {\n                // DEPRECATED. Use `Child Function Pattern` instead\n                return \"renderProp\";\n            }\n            if (isFunction(children)) {\n                return \"childFunction\";\n            }\n            if (/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(children)) {\n                return \"child\";\n            }\n            if (Array.isArray(children)) {\n                // DEPRECATED. Wrap children with a single parent\n                return \"childArray\";\n            }\n            // DEPRECATED. Use `Child Function Pattern` instead\n            return \"parent\";\n        };\n        var skipOnMount = props.skipOnMount, refreshMode = props.refreshMode, _a = props.refreshRate, refreshRate = _a === void 0 ? 1000 : _a, refreshOptions = props.refreshOptions;\n        _this.state = {\n            width: undefined,\n            height: undefined\n        };\n        _this.skipOnMount = skipOnMount;\n        _this.targetRef = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n        _this.observableElement = null;\n        if (isSSR()) {\n            return _this;\n        }\n        _this.resizeHandler = patchResizeHandler(_this.createResizeHandler, refreshMode, refreshRate, refreshOptions);\n        _this.resizeObserver = new window.ResizeObserver(_this.resizeHandler);\n        return _this;\n    }\n    ResizeDetector.prototype.componentDidMount = function() {\n        this.attachObserver();\n    };\n    ResizeDetector.prototype.componentDidUpdate = function() {\n        this.attachObserver();\n    };\n    ResizeDetector.prototype.componentWillUnmount = function() {\n        if (isSSR()) {\n            return;\n        }\n        this.observableElement = null;\n        this.resizeObserver.disconnect();\n        this.cancelHandler();\n    };\n    ResizeDetector.prototype.render = function() {\n        var _a = this.props, render = _a.render, children = _a.children, _b = _a.nodeType, WrapperTag = _b === void 0 ? \"div\" : _b;\n        var _c = this.state, width = _c.width, height = _c.height;\n        var childProps = {\n            width: width,\n            height: height,\n            targetRef: this.targetRef\n        };\n        var renderType = this.getRenderType();\n        var typedChildren;\n        switch(renderType){\n            case \"renderProp\":\n                return render && render(childProps);\n            case \"childFunction\":\n                typedChildren = children;\n                return typedChildren(childProps);\n            case \"child\":\n                // @TODO bug prone logic\n                typedChildren = children;\n                if (typedChildren.type && typeof typedChildren.type === \"string\") {\n                    // child is a native DOM elements such as div, span etc\n                    childProps.targetRef;\n                    var nativeProps = __rest(childProps, [\n                        \"targetRef\"\n                    ]);\n                    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(typedChildren, nativeProps);\n                }\n                // class or functional component otherwise\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(typedChildren, childProps);\n            case \"childArray\":\n                typedChildren = children;\n                return typedChildren.map(function(el) {\n                    return !!el && /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(el, childProps);\n                });\n            default:\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(WrapperTag, null);\n        }\n    };\n    return ResizeDetector;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\nfunction withResizeDetector(ComponentInner, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var ResizeDetectorHOC = /** @class */ function(_super) {\n        __extends(ResizeDetectorHOC, _super);\n        function ResizeDetectorHOC() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.ref = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n            return _this;\n        }\n        ResizeDetectorHOC.prototype.render = function() {\n            var _a = this.props, forwardedRef = _a.forwardedRef, rest = __rest(_a, [\n                \"forwardedRef\"\n            ]);\n            var targetRef = forwardedRef !== null && forwardedRef !== void 0 ? forwardedRef : this.ref;\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResizeDetector, __assign({}, options, {\n                targetRef: targetRef\n            }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ComponentInner, __assign({\n                targetRef: targetRef\n            }, rest)));\n        };\n        return ResizeDetectorHOC;\n    }(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n    function forwardRefWrapper(props, ref) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResizeDetectorHOC, __assign({}, props, {\n            forwardedRef: ref\n        }));\n    }\n    var name = ComponentInner.displayName || ComponentInner.name;\n    forwardRefWrapper.displayName = \"withResizeDetector(\".concat(name, \")\");\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(forwardRefWrapper);\n}\nvar useEnhancedEffect = isSSR() ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\nfunction useResizeDetector(props) {\n    if (props === void 0) {\n        props = {};\n    }\n    var _a = props.skipOnMount, skipOnMount = _a === void 0 ? false : _a, refreshMode = props.refreshMode, _b = props.refreshRate, refreshRate = _b === void 0 ? 1000 : _b, refreshOptions = props.refreshOptions, _c = props.handleWidth, handleWidth = _c === void 0 ? true : _c, _d = props.handleHeight, handleHeight = _d === void 0 ? true : _d, targetRef = props.targetRef, observerOptions = props.observerOptions, onResize = props.onResize;\n    var skipResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(skipOnMount);\n    var localRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var ref = targetRef !== null && targetRef !== void 0 ? targetRef : localRef;\n    var resizeHandler = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        width: undefined,\n        height: undefined\n    }), size = _e[0], setSize = _e[1];\n    useEnhancedEffect(function() {\n        if (isSSR()) {\n            return;\n        }\n        var notifyResize = createNotifier(onResize, setSize, handleWidth, handleHeight);\n        var resizeCallback = function(entries) {\n            if (!handleWidth && !handleHeight) return;\n            entries.forEach(function(entry) {\n                var _a = entry && entry.contentRect || {}, width = _a.width, height = _a.height;\n                var shouldSetSize = !skipResize.current && !isSSR();\n                if (shouldSetSize) {\n                    notifyResize({\n                        width: width,\n                        height: height\n                    });\n                }\n                skipResize.current = false;\n            });\n        };\n        resizeHandler.current = patchResizeHandler(resizeCallback, refreshMode, refreshRate, refreshOptions);\n        var resizeObserver = new window.ResizeObserver(resizeHandler.current);\n        if (ref.current) {\n            // Something wrong with typings here...\n            resizeObserver.observe(ref.current, observerOptions);\n        }\n        return function() {\n            resizeObserver.disconnect();\n            var patchedResizeHandler = resizeHandler.current;\n            if (patchedResizeHandler && patchedResizeHandler.cancel) {\n                patchedResizeHandler.cancel();\n            }\n        };\n    }, [\n        refreshMode,\n        refreshRate,\n        refreshOptions,\n        handleWidth,\n        handleHeight,\n        onResize,\n        observerOptions,\n        ref.current\n    ]);\n    return __assign({\n        ref: ref\n    }, size);\n}\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXplLWRldGVjdG9yL2J1aWxkL2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTRCO0FBQXVJO0FBQW9DOzs7Ozs7Ozs7Ozs7OzhFQWF6SDtBQUM5RSwyQkFBMkIsR0FFM0IsSUFBSVksZ0JBQWdCLFNBQVNDLENBQUMsRUFBRUMsQ0FBQztJQUM3QkYsZ0JBQWdCRyxPQUFPQyxjQUFjLElBQ2hDO1FBQUVDLFdBQVcsRUFBRTtJQUFDLGNBQWFDLFNBQVMsU0FBVUwsQ0FBQyxFQUFFQyxDQUFDO1FBQUlELEVBQUVJLFNBQVMsR0FBR0g7SUFBRyxLQUMxRSxTQUFVRCxDQUFDLEVBQUVDLENBQUM7UUFBSSxJQUFLLElBQUlLLEtBQUtMLEVBQUcsSUFBSUMsT0FBT0ssU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtJQUFFO0lBQ3BHLE9BQU9QLGNBQWNDLEdBQUdDO0FBQzVCO0FBRUEsU0FBU1MsVUFBVVYsQ0FBQyxFQUFFQyxDQUFDO0lBQ25CLElBQUksT0FBT0EsTUFBTSxjQUFjQSxNQUFNLE1BQ2pDLE1BQU0sSUFBSVUsVUFBVSx5QkFBeUJDLE9BQU9YLEtBQUs7SUFDN0RGLGNBQWNDLEdBQUdDO0lBQ2pCLFNBQVNZO1FBQU8sSUFBSSxDQUFDQyxXQUFXLEdBQUdkO0lBQUc7SUFDdENBLEVBQUVPLFNBQVMsR0FBR04sTUFBTSxPQUFPQyxPQUFPYSxNQUFNLENBQUNkLEtBQU1ZLENBQUFBLEdBQUdOLFNBQVMsR0FBR04sRUFBRU0sU0FBUyxFQUFFLElBQUlNLElBQUc7QUFDdEY7QUFFQSxJQUFJRyxXQUFXO0lBQ1hBLFdBQVdkLE9BQU9lLE1BQU0sSUFBSSxTQUFTRCxTQUFTRSxDQUFDO1FBQzNDLElBQUssSUFBSUMsR0FBR0MsSUFBSSxHQUFHQyxJQUFJQyxVQUFVQyxNQUFNLEVBQUVILElB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T0E7d0JBQU9DLFFBQVFBO29CQUFPO2dCQUNoRDtnQkFDQWlFLFdBQVd0RCxPQUFPLEdBQUc7WUFDekI7UUFDSjtRQUNBSixjQUFjSSxPQUFPLEdBQUc5QixtQkFBbUJDLGdCQUFnQkMsYUFBYUMsYUFBYUM7UUFDckYsSUFBSTZCLGlCQUFpQixJQUFJL0osT0FBT3dMLGNBQWMsQ0FBQ2hDLGNBQWNJLE9BQU87UUFDcEUsSUFBSTRDLElBQUk1QyxPQUFPLEVBQUU7WUFDYix1Q0FBdUM7WUFDdkNHLGVBQWVDLE9BQU8sQ0FBQ3dDLElBQUk1QyxPQUFPLEVBQUVEO1FBQ3hDO1FBQ0EsT0FBTztZQUNISSxlQUFlNkIsVUFBVTtZQUN6QixJQUFJMEIsdUJBQXVCOUQsY0FBY0ksT0FBTztZQUNoRCxJQUFJMEQsd0JBQXdCQSxxQkFBcUJuRyxNQUFNLEVBQUU7Z0JBQ3JEbUcscUJBQXFCbkcsTUFBTTtZQUMvQjtRQUNKO0lBQ0osR0FBRztRQUFDYTtRQUFhQztRQUFhQztRQUFnQlc7UUFBYUM7UUFBY0g7UUFBVWdCO1FBQWlCNkMsSUFBSTVDLE9BQU87S0FBQztJQUNoSCxPQUFPNUssU0FBUztRQUFFd04sS0FBS0E7SUFBSSxHQUFHYTtBQUNsQztBQUF3RSxzQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3JsZHMtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6ZS1kZXRlY3Rvci9idWlsZC9pbmRleC5lc20uanM/MDE0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQqYXMgUmVhY3QgZnJvbSdyZWFjdCc7aW1wb3J0IHtjbG9uZUVsZW1lbnQsaXNWYWxpZEVsZW1lbnQsY3JlYXRlUmVmLFB1cmVDb21wb25lbnQsQ29tcG9uZW50LGZvcndhcmRSZWYsdXNlUmVmLHVzZVN0YXRlLHVzZUVmZmVjdCx1c2VMYXlvdXRFZmZlY3R9ZnJvbSdyZWFjdCc7aW1wb3J0IHtmaW5kRE9NTm9kZX1mcm9tJ3JlYWN0LWRvbSc7LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59dmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdCQzKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0JDM7LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cblxudmFyIGZyZWVHbG9iYWwkMSA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBjb21tb25qc0dsb2JhbDtcblxudmFyIF9mcmVlR2xvYmFsID0gZnJlZUdsb2JhbCQxO3ZhciBmcmVlR2xvYmFsID0gX2ZyZWVHbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCQyID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgX3Jvb3QgPSByb290JDI7dmFyIHJvb3QkMSA9IF9yb290O1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93JDEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QkMS5EYXRlLm5vdygpO1xufTtcblxudmFyIG5vd18xID0gbm93JDE7LyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG5cbnZhciByZVdoaXRlc3BhY2UgPSAvXFxzLztcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgkMShzdHJpbmcpIHtcbiAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gIHJldHVybiBpbmRleDtcbn1cblxudmFyIF90cmltbWVkRW5kSW5kZXggPSB0cmltbWVkRW5kSW5kZXgkMTt2YXIgdHJpbW1lZEVuZEluZGV4ID0gX3RyaW1tZWRFbmRJbmRleDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRyaW0kMShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1xuICAgID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgJycpXG4gICAgOiBzdHJpbmc7XG59XG5cbnZhciBfYmFzZVRyaW0gPSBiYXNlVHJpbSQxO3ZhciByb290ID0gX3Jvb3Q7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCQyID0gcm9vdC5TeW1ib2w7XG5cbnZhciBfU3ltYm9sID0gU3ltYm9sJDI7dmFyIFN5bWJvbCQxID0gX1N5bWJvbDtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvJDEuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8kMS50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IFN5bWJvbCQxID8gU3ltYm9sJDEudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnJDEodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWckMSksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nJDEuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV0gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9nZXRSYXdUYWcgPSBnZXRSYXdUYWckMTsvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmckMSh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbnZhciBfb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RUb1N0cmluZyQxO3ZhciBTeW1ib2wgPSBfU3ltYm9sLFxuICAgIGdldFJhd1RhZyA9IF9nZXRSYXdUYWcsXG4gICAgb2JqZWN0VG9TdHJpbmcgPSBfb2JqZWN0VG9TdHJpbmc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWckMSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbnZhciBfYmFzZUdldFRhZyA9IGJhc2VHZXRUYWckMTsvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdExpa2UkMSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbnZhciBpc09iamVjdExpa2VfMSA9IGlzT2JqZWN0TGlrZSQxO3ZhciBiYXNlR2V0VGFnID0gX2Jhc2VHZXRUYWcsXG4gICAgaXNPYmplY3RMaWtlID0gaXNPYmplY3RMaWtlXzE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCQxKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG52YXIgaXNTeW1ib2xfMSA9IGlzU3ltYm9sJDE7dmFyIGJhc2VUcmltID0gX2Jhc2VUcmltLFxuICAgIGlzT2JqZWN0JDIgPSBpc09iamVjdF8xLFxuICAgIGlzU3ltYm9sID0gaXNTeW1ib2xfMTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyJDEodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QkMih2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdCQyKG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbnZhciB0b051bWJlcl8xID0gdG9OdW1iZXIkMTt2YXIgaXNPYmplY3QkMSA9IGlzT2JqZWN0XzEsXG4gICAgbm93ID0gbm93XzEsXG4gICAgdG9OdW1iZXIgPSB0b051bWJlcl8xO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUJDEgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlJDEoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCQxKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0JDEob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmdcbiAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgIDogdGltZVdhaXRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG52YXIgZGVib3VuY2VfMSA9IGRlYm91bmNlJDE7dmFyIGRlYm91bmNlID0gZGVib3VuY2VfMSxcbiAgICBpc09iamVjdCA9IGlzT2JqZWN0XzE7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbnZhciB0aHJvdHRsZV8xID0gdGhyb3R0bGU7dmFyIHBhdGNoUmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uIChyZXNpemVDYWxsYmFjaywgcmVmcmVzaE1vZGUsIHJlZnJlc2hSYXRlLCByZWZyZXNoT3B0aW9ucykge1xyXG4gICAgc3dpdGNoIChyZWZyZXNoTW9kZSkge1xyXG4gICAgICAgIGNhc2UgJ2RlYm91bmNlJzpcclxuICAgICAgICAgICAgcmV0dXJuIGRlYm91bmNlXzEocmVzaXplQ2FsbGJhY2ssIHJlZnJlc2hSYXRlLCByZWZyZXNoT3B0aW9ucyk7XHJcbiAgICAgICAgY2FzZSAndGhyb3R0bGUnOlxyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3R0bGVfMShyZXNpemVDYWxsYmFjaywgcmVmcmVzaFJhdGUsIHJlZnJlc2hPcHRpb25zKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gcmVzaXplQ2FsbGJhY2s7XHJcbiAgICB9XHJcbn07XHJcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbic7IH07XHJcbnZhciBpc1NTUiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnOyB9O1xyXG52YXIgaXNET01FbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50IHx8IGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRG9jdW1lbnQ7IH07XHJcbnZhciBjcmVhdGVOb3RpZmllciA9IGZ1bmN0aW9uIChvblJlc2l6ZSwgc2V0U2l6ZSwgaGFuZGxlV2lkdGgsIGhhbmRsZUhlaWdodCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgc2V0U2l6ZShmdW5jdGlvbiAocHJldikge1xyXG4gICAgICAgICAgICBpZiAocHJldi53aWR0aCA9PT0gd2lkdGggJiYgcHJldi5oZWlnaHQgPT09IGhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiBkaW1lbnNpb25zIGhhdmVuJ3QgY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChwcmV2LndpZHRoID09PSB3aWR0aCAmJiAhaGFuZGxlSGVpZ2h0KSB8fCAocHJldi5oZWlnaHQgPT09IGhlaWdodCAmJiAhaGFuZGxlV2lkdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGBoYW5kbGVIZWlnaHQvaGFuZGxlV2lkdGhgIHByb3BzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob25SZXNpemUgJiYgaXNGdW5jdGlvbihvblJlc2l6ZSkpIHtcclxuICAgICAgICAgICAgICAgIG9uUmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn07dmFyIFJlc2l6ZURldGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJlc2l6ZURldGVjdG9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmVzaXplRGV0ZWN0b3IocHJvcHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jYW5jZWxIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMucmVzaXplSGFuZGxlciAmJiBfdGhpcy5yZXNpemVIYW5kbGVyLmNhbmNlbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsIGRlYm91bmNlZCBoYW5kbGVyXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNpemVIYW5kbGVyLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucmVzaXplSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLmF0dGFjaE9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgdGFyZ2V0UmVmID0gX2EudGFyZ2V0UmVmLCBvYnNlcnZlck9wdGlvbnMgPSBfYS5vYnNlcnZlck9wdGlvbnM7XHJcbiAgICAgICAgICAgIGlmIChpc1NTUigpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRhcmdldFJlZiAmJiB0YXJnZXRSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudGFyZ2V0UmVmLmN1cnJlbnQgPSB0YXJnZXRSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IF90aGlzLmdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjYW4ndCBmaW5kIGVsZW1lbnQgdG8gb2JzZXJ2ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5vYnNlcnZhYmxlRWxlbWVudCAmJiBfdGhpcy5vYnNlcnZhYmxlRWxlbWVudCA9PT0gZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IG9ic2VydmVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMub2JzZXJ2YWJsZUVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgICBfdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIG9ic2VydmVyT3B0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgcXVlcnlTZWxlY3RvciA9IF9hLnF1ZXJ5U2VsZWN0b3IsIHRhcmdldERvbUVsID0gX2EudGFyZ2V0RG9tRWw7XHJcbiAgICAgICAgICAgIGlmIChpc1NTUigpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgcGFzcyBhIHF1ZXJ5U2VsZWN0b3JcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5U2VsZWN0b3IpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeVNlbGVjdG9yKTtcclxuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSBwYXNzIGEgRE9NIGVsZW1lbnRcclxuICAgICAgICAgICAgaWYgKHRhcmdldERvbUVsICYmIGlzRE9NRWxlbWVudCh0YXJnZXREb21FbCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0RG9tRWw7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgcGFzcyBhIFJlYWN0IHJlZiB1c2luZyBSZWFjdC5jcmVhdGVSZWYoKVxyXG4gICAgICAgICAgICBpZiAoX3RoaXMudGFyZ2V0UmVmICYmIGlzRE9NRWxlbWVudChfdGhpcy50YXJnZXRSZWYuY3VycmVudCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudGFyZ2V0UmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIC8vIHRoZSB3b3JzZSBjYXNlIHdoZW4gd2UgZG9uJ3QgcmVjZWl2ZSBhbnkgaW5mb3JtYXRpb24gZnJvbSB0aGUgcGFyZW50IGFuZCB0aGUgbGlicmFyeSBkb2Vzbid0IGFkZCBhbnkgd3JhcHBlcnNcclxuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byB1c2UgYSBkZXByZWNhdGVkIGBmaW5kRE9NTm9kZWAgbWV0aG9kIGluIG9yZGVyIHRvIGZpbmQgYSBET00gZWxlbWVudCB0byBhdHRhY2ggdG9cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRFbGVtZW50ID0gZmluZERPTU5vZGUoX3RoaXMpO1xyXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJUeXBlID0gX3RoaXMuZ2V0UmVuZGVyVHlwZSgpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHJlbmRlclR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlbmRlclByb3AnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoaWxkRnVuY3Rpb24nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoaWxkJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjaGlsZEFycmF5JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5jcmVhdGVSZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gKGVudHJpZXMpIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIF9iID0gX2EuaGFuZGxlV2lkdGgsIGhhbmRsZVdpZHRoID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYiwgX2MgPSBfYS5oYW5kbGVIZWlnaHQsIGhhbmRsZUhlaWdodCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIG9uUmVzaXplID0gX2Eub25SZXNpemU7XHJcbiAgICAgICAgICAgIGlmICghaGFuZGxlV2lkdGggJiYgIWhhbmRsZUhlaWdodClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdmFyIG5vdGlmeVJlc2l6ZSA9IGNyZWF0ZU5vdGlmaWVyKG9uUmVzaXplLCBfdGhpcy5zZXRTdGF0ZS5iaW5kKF90aGlzKSwgaGFuZGxlV2lkdGgsIGhhbmRsZUhlaWdodCk7XHJcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IChlbnRyeSAmJiBlbnRyeS5jb250ZW50UmVjdCkgfHwge30sIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciBzaG91bGRTZXRTaXplID0gIV90aGlzLnNraXBPbk1vdW50ICYmICFpc1NTUigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFNldFNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBub3RpZnlSZXNpemUoeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2tpcE9uTW91bnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5nZXRSZW5kZXJUeXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgcmVuZGVyID0gX2EucmVuZGVyLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihyZW5kZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBERVBSRUNBVEVELiBVc2UgYENoaWxkIEZ1bmN0aW9uIFBhdHRlcm5gIGluc3RlYWRcclxuICAgICAgICAgICAgICAgIHJldHVybiAncmVuZGVyUHJvcCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NoaWxkRnVuY3Rpb24nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnY2hpbGQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gREVQUkVDQVRFRC4gV3JhcCBjaGlsZHJlbiB3aXRoIGEgc2luZ2xlIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdjaGlsZEFycmF5JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBERVBSRUNBVEVELiBVc2UgYENoaWxkIEZ1bmN0aW9uIFBhdHRlcm5gIGluc3RlYWRcclxuICAgICAgICAgICAgcmV0dXJuICdwYXJlbnQnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHNraXBPbk1vdW50ID0gcHJvcHMuc2tpcE9uTW91bnQsIHJlZnJlc2hNb2RlID0gcHJvcHMucmVmcmVzaE1vZGUsIF9hID0gcHJvcHMucmVmcmVzaFJhdGUsIHJlZnJlc2hSYXRlID0gX2EgPT09IHZvaWQgMCA/IDEwMDAgOiBfYSwgcmVmcmVzaE9wdGlvbnMgPSBwcm9wcy5yZWZyZXNoT3B0aW9ucztcclxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB1bmRlZmluZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLnNraXBPbk1vdW50ID0gc2tpcE9uTW91bnQ7XHJcbiAgICAgICAgX3RoaXMudGFyZ2V0UmVmID0gY3JlYXRlUmVmKCk7XHJcbiAgICAgICAgX3RoaXMub2JzZXJ2YWJsZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIGlmIChpc1NTUigpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMucmVzaXplSGFuZGxlciA9IHBhdGNoUmVzaXplSGFuZGxlcihfdGhpcy5jcmVhdGVSZXNpemVIYW5kbGVyLCByZWZyZXNoTW9kZSwgcmVmcmVzaFJhdGUsIHJlZnJlc2hPcHRpb25zKTtcclxuICAgICAgICBfdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIoX3RoaXMucmVzaXplSGFuZGxlcik7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgUmVzaXplRGV0ZWN0b3IucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXR0YWNoT2JzZXJ2ZXIoKTtcclxuICAgIH07XHJcbiAgICBSZXNpemVEZXRlY3Rvci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXR0YWNoT2JzZXJ2ZXIoKTtcclxuICAgIH07XHJcbiAgICBSZXNpemVEZXRlY3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGlzU1NSKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9ic2VydmFibGVFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB0aGlzLmNhbmNlbEhhbmRsZXIoKTtcclxuICAgIH07XHJcbiAgICBSZXNpemVEZXRlY3Rvci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHJlbmRlciA9IF9hLnJlbmRlciwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgX2IgPSBfYS5ub2RlVHlwZSwgV3JhcHBlclRhZyA9IF9iID09PSB2b2lkIDAgPyAnZGl2JyA6IF9iO1xyXG4gICAgICAgIHZhciBfYyA9IHRoaXMuc3RhdGUsIHdpZHRoID0gX2Mud2lkdGgsIGhlaWdodCA9IF9jLmhlaWdodDtcclxuICAgICAgICB2YXIgY2hpbGRQcm9wcyA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgdGFyZ2V0UmVmOiB0aGlzLnRhcmdldFJlZiB9O1xyXG4gICAgICAgIHZhciByZW5kZXJUeXBlID0gdGhpcy5nZXRSZW5kZXJUeXBlKCk7XHJcbiAgICAgICAgdmFyIHR5cGVkQ2hpbGRyZW47XHJcbiAgICAgICAgc3dpdGNoIChyZW5kZXJUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JlbmRlclByb3AnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlciAmJiByZW5kZXIoY2hpbGRQcm9wcyk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkRnVuY3Rpb24nOlxyXG4gICAgICAgICAgICAgICAgdHlwZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkQ2hpbGRyZW4oY2hpbGRQcm9wcyk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkJzpcclxuICAgICAgICAgICAgICAgIC8vIEBUT0RPIGJ1ZyBwcm9uZSBsb2dpY1xyXG4gICAgICAgICAgICAgICAgdHlwZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVkQ2hpbGRyZW4udHlwZSAmJiB0eXBlb2YgdHlwZWRDaGlsZHJlbi50eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoaWxkIGlzIGEgbmF0aXZlIERPTSBlbGVtZW50cyBzdWNoIGFzIGRpdiwgc3BhbiBldGNcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BzLnRhcmdldFJlZjsgdmFyIG5hdGl2ZVByb3BzID0gX19yZXN0KGNoaWxkUHJvcHMsIFtcInRhcmdldFJlZlwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudCh0eXBlZENoaWxkcmVuLCBuYXRpdmVQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjbGFzcyBvciBmdW5jdGlvbmFsIGNvbXBvbmVudCBvdGhlcndpc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQodHlwZWRDaGlsZHJlbiwgY2hpbGRQcm9wcyk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkQXJyYXknOlxyXG4gICAgICAgICAgICAgICAgdHlwZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkQ2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbCAmJiBjbG9uZUVsZW1lbnQoZWwsIGNoaWxkUHJvcHMpOyB9KTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZXJUYWcsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzaXplRGV0ZWN0b3I7XHJcbn0oUHVyZUNvbXBvbmVudCkpO2Z1bmN0aW9uIHdpdGhSZXNpemVEZXRlY3RvcihDb21wb25lbnRJbm5lciwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgIHZhciBSZXNpemVEZXRlY3RvckhPQyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUmVzaXplRGV0ZWN0b3JIT0MsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUmVzaXplRGV0ZWN0b3JIT0MoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5yZWYgPSBjcmVhdGVSZWYoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBSZXNpemVEZXRlY3RvckhPQy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBmb3J3YXJkZWRSZWYgPSBfYS5mb3J3YXJkZWRSZWYsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImZvcndhcmRlZFJlZlwiXSk7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRSZWYgPSBmb3J3YXJkZWRSZWYgIT09IG51bGwgJiYgZm9yd2FyZGVkUmVmICE9PSB2b2lkIDAgPyBmb3J3YXJkZWRSZWYgOiB0aGlzLnJlZjtcclxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlc2l6ZURldGVjdG9yLCBfX2Fzc2lnbih7fSwgb3B0aW9ucywgeyB0YXJnZXRSZWY6IHRhcmdldFJlZiB9KSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50SW5uZXIsIF9fYXNzaWduKHsgdGFyZ2V0UmVmOiB0YXJnZXRSZWYgfSwgcmVzdCkpKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUmVzaXplRGV0ZWN0b3JIT0M7XHJcbiAgICB9KENvbXBvbmVudCkpO1xyXG4gICAgZnVuY3Rpb24gZm9yd2FyZFJlZldyYXBwZXIocHJvcHMsIHJlZikge1xyXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlc2l6ZURldGVjdG9ySE9DLCBfX2Fzc2lnbih7fSwgcHJvcHMsIHsgZm9yd2FyZGVkUmVmOiByZWYgfSkpO1xyXG4gICAgfVxyXG4gICAgdmFyIG5hbWUgPSBDb21wb25lbnRJbm5lci5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnRJbm5lci5uYW1lO1xyXG4gICAgZm9yd2FyZFJlZldyYXBwZXIuZGlzcGxheU5hbWUgPSBcIndpdGhSZXNpemVEZXRlY3RvcihcIi5jb25jYXQobmFtZSwgXCIpXCIpO1xyXG4gICAgcmV0dXJuIGZvcndhcmRSZWYoZm9yd2FyZFJlZldyYXBwZXIpO1xyXG59dmFyIHVzZUVuaGFuY2VkRWZmZWN0ID0gaXNTU1IoKSA/IHVzZUVmZmVjdCA6IHVzZUxheW91dEVmZmVjdDtcclxuZnVuY3Rpb24gdXNlUmVzaXplRGV0ZWN0b3IocHJvcHMpIHtcclxuICAgIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7IHByb3BzID0ge307IH1cclxuICAgIHZhciBfYSA9IHByb3BzLnNraXBPbk1vdW50LCBza2lwT25Nb3VudCA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hLCByZWZyZXNoTW9kZSA9IHByb3BzLnJlZnJlc2hNb2RlLCBfYiA9IHByb3BzLnJlZnJlc2hSYXRlLCByZWZyZXNoUmF0ZSA9IF9iID09PSB2b2lkIDAgPyAxMDAwIDogX2IsIHJlZnJlc2hPcHRpb25zID0gcHJvcHMucmVmcmVzaE9wdGlvbnMsIF9jID0gcHJvcHMuaGFuZGxlV2lkdGgsIGhhbmRsZVdpZHRoID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgX2QgPSBwcm9wcy5oYW5kbGVIZWlnaHQsIGhhbmRsZUhlaWdodCA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2QsIHRhcmdldFJlZiA9IHByb3BzLnRhcmdldFJlZiwgb2JzZXJ2ZXJPcHRpb25zID0gcHJvcHMub2JzZXJ2ZXJPcHRpb25zLCBvblJlc2l6ZSA9IHByb3BzLm9uUmVzaXplO1xyXG4gICAgdmFyIHNraXBSZXNpemUgPSB1c2VSZWYoc2tpcE9uTW91bnQpO1xyXG4gICAgdmFyIGxvY2FsUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gICAgdmFyIHJlZiA9ICh0YXJnZXRSZWYgIT09IG51bGwgJiYgdGFyZ2V0UmVmICE9PSB2b2lkIDAgPyB0YXJnZXRSZWYgOiBsb2NhbFJlZik7XHJcbiAgICB2YXIgcmVzaXplSGFuZGxlciA9IHVzZVJlZigpO1xyXG4gICAgdmFyIF9lID0gdXNlU3RhdGUoe1xyXG4gICAgICAgIHdpZHRoOiB1bmRlZmluZWQsXHJcbiAgICAgICAgaGVpZ2h0OiB1bmRlZmluZWRcclxuICAgIH0pLCBzaXplID0gX2VbMF0sIHNldFNpemUgPSBfZVsxXTtcclxuICAgIHVzZUVuaGFuY2VkRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoaXNTU1IoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBub3RpZnlSZXNpemUgPSBjcmVhdGVOb3RpZmllcihvblJlc2l6ZSwgc2V0U2l6ZSwgaGFuZGxlV2lkdGgsIGhhbmRsZUhlaWdodCk7XHJcbiAgICAgICAgdmFyIHJlc2l6ZUNhbGxiYWNrID0gZnVuY3Rpb24gKGVudHJpZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFoYW5kbGVXaWR0aCAmJiAhaGFuZGxlSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSAoZW50cnkgJiYgZW50cnkuY29udGVudFJlY3QpIHx8IHt9LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hvdWxkU2V0U2l6ZSA9ICFza2lwUmVzaXplLmN1cnJlbnQgJiYgIWlzU1NSKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU2V0U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmeVJlc2l6ZSh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBza2lwUmVzaXplLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXNpemVIYW5kbGVyLmN1cnJlbnQgPSBwYXRjaFJlc2l6ZUhhbmRsZXIocmVzaXplQ2FsbGJhY2ssIHJlZnJlc2hNb2RlLCByZWZyZXNoUmF0ZSwgcmVmcmVzaE9wdGlvbnMpO1xyXG4gICAgICAgIHZhciByZXNpemVPYnNlcnZlciA9IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIocmVzaXplSGFuZGxlci5jdXJyZW50KTtcclxuICAgICAgICBpZiAocmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdyb25nIHdpdGggdHlwaW5ncyBoZXJlLi4uXHJcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVmLmN1cnJlbnQsIG9ic2VydmVyT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgdmFyIHBhdGNoZWRSZXNpemVIYW5kbGVyID0gcmVzaXplSGFuZGxlci5jdXJyZW50O1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hlZFJlc2l6ZUhhbmRsZXIgJiYgcGF0Y2hlZFJlc2l6ZUhhbmRsZXIuY2FuY2VsKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaGVkUmVzaXplSGFuZGxlci5jYW5jZWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbcmVmcmVzaE1vZGUsIHJlZnJlc2hSYXRlLCByZWZyZXNoT3B0aW9ucywgaGFuZGxlV2lkdGgsIGhhbmRsZUhlaWdodCwgb25SZXNpemUsIG9ic2VydmVyT3B0aW9ucywgcmVmLmN1cnJlbnRdKTtcclxuICAgIHJldHVybiBfX2Fzc2lnbih7IHJlZjogcmVmIH0sIHNpemUpO1xyXG59ZXhwb3J0e1Jlc2l6ZURldGVjdG9yIGFzIGRlZmF1bHQsdXNlUmVzaXplRGV0ZWN0b3Isd2l0aFJlc2l6ZURldGVjdG9yfTsvLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjbG9uZUVsZW1lbnQiLCJpc1ZhbGlkRWxlbWVudCIsImNyZWF0ZVJlZiIsIlB1cmVDb21wb25lbnQiLCJDb21wb25lbnQiLCJmb3J3YXJkUmVmIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJmaW5kRE9NTm9kZSIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19leHRlbmRzIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFwcGx5IiwiX19yZXN0IiwiZSIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNvbW1vbmpzR2xvYmFsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJpc09iamVjdCQzIiwidmFsdWUiLCJ0eXBlIiwiaXNPYmplY3RfMSIsImZyZWVHbG9iYWwkMSIsIl9mcmVlR2xvYmFsIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCQyIiwiRnVuY3Rpb24iLCJfcm9vdCIsInJvb3QkMSIsIm5vdyQxIiwiRGF0ZSIsIm5vdyIsIm5vd18xIiwicmVXaGl0ZXNwYWNlIiwidHJpbW1lZEVuZEluZGV4JDEiLCJzdHJpbmciLCJpbmRleCIsInRlc3QiLCJjaGFyQXQiLCJfdHJpbW1lZEVuZEluZGV4IiwidHJpbW1lZEVuZEluZGV4IiwicmVUcmltU3RhcnQiLCJiYXNlVHJpbSQxIiwic2xpY2UiLCJyZXBsYWNlIiwiX2Jhc2VUcmltIiwicm9vdCIsIlN5bWJvbCQyIiwiU3ltYm9sIiwiX1N5bWJvbCIsIlN5bWJvbCQxIiwib2JqZWN0UHJvdG8kMSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nJDEiLCJ0b1N0cmluZyIsInN5bVRvU3RyaW5nVGFnJDEiLCJ0b1N0cmluZ1RhZyIsInVuZGVmaW5lZCIsImdldFJhd1RhZyQxIiwiaXNPd24iLCJ0YWciLCJ1bm1hc2tlZCIsInJlc3VsdCIsIl9nZXRSYXdUYWciLCJvYmplY3RQcm90byIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwib2JqZWN0VG9TdHJpbmckMSIsIl9vYmplY3RUb1N0cmluZyIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwiYmFzZUdldFRhZyQxIiwiX2Jhc2VHZXRUYWciLCJpc09iamVjdExpa2UkMSIsImlzT2JqZWN0TGlrZV8xIiwiYmFzZUdldFRhZyIsImlzT2JqZWN0TGlrZSIsInN5bWJvbFRhZyIsImlzU3ltYm9sJDEiLCJpc1N5bWJvbF8xIiwiYmFzZVRyaW0iLCJpc09iamVjdCQyIiwiaXNTeW1ib2wiLCJOQU4iLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsImZyZWVQYXJzZUludCIsInBhcnNlSW50IiwidG9OdW1iZXIkMSIsIm90aGVyIiwidmFsdWVPZiIsImlzQmluYXJ5IiwidG9OdW1iZXJfMSIsImlzT2JqZWN0JDEiLCJ0b051bWJlciIsIkZVTkNfRVJST1JfVEVYVCQxIiwibmF0aXZlTWF4IiwiTWF0aCIsIm1heCIsIm5hdGl2ZU1pbiIsIm1pbiIsImRlYm91bmNlJDEiLCJmdW5jIiwid2FpdCIsIm9wdGlvbnMiLCJsYXN0QXJncyIsImxhc3RUaGlzIiwibWF4V2FpdCIsInRpbWVySWQiLCJsYXN0Q2FsbFRpbWUiLCJsYXN0SW52b2tlVGltZSIsImxlYWRpbmciLCJtYXhpbmciLCJ0cmFpbGluZyIsImludm9rZUZ1bmMiLCJ0aW1lIiwiYXJncyIsInRoaXNBcmciLCJsZWFkaW5nRWRnZSIsInNldFRpbWVvdXQiLCJ0aW1lckV4cGlyZWQiLCJyZW1haW5pbmdXYWl0IiwidGltZVNpbmNlTGFzdENhbGwiLCJ0aW1lU2luY2VMYXN0SW52b2tlIiwidGltZVdhaXRpbmciLCJzaG91bGRJbnZva2UiLCJ0cmFpbGluZ0VkZ2UiLCJjYW5jZWwiLCJjbGVhclRpbWVvdXQiLCJmbHVzaCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJkZWJvdW5jZV8xIiwiZGVib3VuY2UiLCJpc09iamVjdCIsIkZVTkNfRVJST1JfVEVYVCIsInRocm90dGxlIiwidGhyb3R0bGVfMSIsInBhdGNoUmVzaXplSGFuZGxlciIsInJlc2l6ZUNhbGxiYWNrIiwicmVmcmVzaE1vZGUiLCJyZWZyZXNoUmF0ZSIsInJlZnJlc2hPcHRpb25zIiwiaXNGdW5jdGlvbiIsImZuIiwiaXNTU1IiLCJpc0RPTUVsZW1lbnQiLCJlbGVtZW50IiwiRWxlbWVudCIsIkhUTUxEb2N1bWVudCIsImNyZWF0ZU5vdGlmaWVyIiwib25SZXNpemUiLCJzZXRTaXplIiwiaGFuZGxlV2lkdGgiLCJoYW5kbGVIZWlnaHQiLCJfYSIsIndpZHRoIiwiaGVpZ2h0IiwicHJldiIsIlJlc2l6ZURldGVjdG9yIiwiX3N1cGVyIiwicHJvcHMiLCJfdGhpcyIsImNhbmNlbEhhbmRsZXIiLCJyZXNpemVIYW5kbGVyIiwiYXR0YWNoT2JzZXJ2ZXIiLCJ0YXJnZXRSZWYiLCJvYnNlcnZlck9wdGlvbnMiLCJjdXJyZW50IiwiZ2V0RWxlbWVudCIsIm9ic2VydmFibGVFbGVtZW50IiwicmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwicXVlcnlTZWxlY3RvciIsInRhcmdldERvbUVsIiwiZG9jdW1lbnQiLCJjdXJyZW50RWxlbWVudCIsInJlbmRlclR5cGUiLCJnZXRSZW5kZXJUeXBlIiwicGFyZW50RWxlbWVudCIsImNyZWF0ZVJlc2l6ZUhhbmRsZXIiLCJlbnRyaWVzIiwiX2IiLCJfYyIsIm5vdGlmeVJlc2l6ZSIsInNldFN0YXRlIiwiYmluZCIsImZvckVhY2giLCJlbnRyeSIsImNvbnRlbnRSZWN0Iiwic2hvdWxkU2V0U2l6ZSIsInNraXBPbk1vdW50IiwicmVuZGVyIiwiY2hpbGRyZW4iLCJpc0FycmF5Iiwic3RhdGUiLCJSZXNpemVPYnNlcnZlciIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJkaXNjb25uZWN0Iiwibm9kZVR5cGUiLCJXcmFwcGVyVGFnIiwiY2hpbGRQcm9wcyIsInR5cGVkQ2hpbGRyZW4iLCJuYXRpdmVQcm9wcyIsIm1hcCIsImVsIiwiY3JlYXRlRWxlbWVudCIsIndpdGhSZXNpemVEZXRlY3RvciIsIkNvbXBvbmVudElubmVyIiwiUmVzaXplRGV0ZWN0b3JIT0MiLCJyZWYiLCJmb3J3YXJkZWRSZWYiLCJyZXN0IiwiZm9yd2FyZFJlZldyYXBwZXIiLCJuYW1lIiwiZGlzcGxheU5hbWUiLCJjb25jYXQiLCJ1c2VFbmhhbmNlZEVmZmVjdCIsInVzZVJlc2l6ZURldGVjdG9yIiwiX2QiLCJza2lwUmVzaXplIiwibG9jYWxSZWYiLCJfZSIsInNpemUiLCJwYXRjaGVkUmVzaXplSGFuZGxlciIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-resize-detector/build/index.esm.js\n");

/***/ })

};
;